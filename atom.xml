<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸡哥]]></title>
  <subtitle><![CDATA[不乱于心,不困于情。不念过往，不畏将来。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://0x520.com/"/>
  <updated>2015-05-26T08:55:41.000Z</updated>
  <id>http://0x520.com/</id>
  
  <author>
    <name><![CDATA[John·Huang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[用mac笔记本演示iPhone应用]]></title>
    <link href="http://0x520.com/2015/05/26/others/1/"/>
    <id>http://0x520.com/2015/05/26/others/1/</id>
    <published>2015-05-26T08:55:00.000Z</published>
    <updated>2015-05-26T08:55:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="找到QuickTime">找到QuickTime</h2><p><img src="/uploads/QQ20150526-1.jpg" alt="找到QuickTime"></p>
<h2 id="新建影片录制">新建影片录制</h2><p><img src="/uploads/QQ20150526-2.jpg" alt="找到QuickTime"></p>
<h2 id="选择从iPhone录制">选择从iPhone录制</h2><p><img src="/uploads/QQ20150526-3.jpg" alt="找到QuickTime"></p>
<h2 id="开始演示吧">开始演示吧</h2><p><img src="/uploads/QQ20150526-4.jpg" alt="找到QuickTime"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="找到QuickTime">找到QuickTime</h2><p><img src="/uploads/QQ20150526-1.jpg" alt="找到QuickTime"></p>
<h2 id="新建影片录制">新建影片录制</h2><p><img src="]]>
    </summary>
    
      <category term="其他" scheme="http://0x520.com/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rails中使用paperclip进行图片上传]]></title>
    <link href="http://0x520.com/2015/05/24/rails/5/"/>
    <id>http://0x520.com/2015/05/24/rails/5/</id>
    <published>2015-05-24T09:02:00.000Z</published>
    <updated>2015-05-24T11:45:57.000Z</updated>
    <content type="html"><![CDATA[<p>参考：<a href="https://github.com/thoughtbot/paperclip" target="_blank" rel="external">https://github.com/thoughtbot/paperclip</a></p>
<h2 id="Requirements">Requirements</h2><p>必须安装ImageMatic才能对图片进行处理</p>
<p>If you’re on Mac OS X, you’ll want to run the following with Homebrew:</p>
<pre><code><span class="keyword">brew </span>install imagemagick
</code></pre><p>检查是否安装成功：</p>
<p>执行 <code>which convert</code> 理论上来说应该返回 <code>/usr/local/bin/convert</code> 说明ImageMatic安装成功了。</p>
<p>编辑 config/environments/development.rb  配置command_path</p>
<pre><code>Paperclip<span class="class">.options</span>[:command_path] = <span class="string">"/usr/local/bin/"</span>
</code></pre><h2 id="安装">安装</h2><p>编辑gemfile</p>
<pre><code><span class="title">gem</span> <span class="string">"paperclip"</span>, <span class="string">"~&gt; 4.2"</span>
</code></pre><p>然后</p>
<pre><code><span class="keyword">bundle </span>install
</code></pre><h2 id="使用">使用</h2><h3 id="model">model</h3><pre><code><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
  has_attached_file <span class="symbol">:avatar</span>, <span class="symbol">:styles</span> =&gt; { <span class="symbol">:medium</span> =&gt; <span class="string">"300x300&gt;"</span>, <span class="symbol">:thumb</span> =&gt; <span class="string">"100x100&gt;"</span> }, <span class="symbol">:default_url</span> =&gt; <span class="string">"/images/:style/missing.png"</span>
  validates_attachment_content_type <span class="symbol">:avatar</span>, <span class="symbol">:content_type</span> =&gt; <span class="regexp">/\Aimage\/.*\Z/</span>
<span class="keyword">end</span>
</code></pre><h3 id="migrateion">migrateion</h3><p>创建一个migration</p>
<pre><code>rails g migration <span class="keyword">add_avatar_columns_t</span>o_users
</code></pre><p>编辑 xxx_add_avatar_columns_to_users</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">AddAvatarColumnsToUsers</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Migration</span></span></span>
  <span class="function"><span class="keyword">def</span> </span><span class="keyword">self</span>.up
    add_attachment <span class="symbol">:users</span>, <span class="symbol">:avatar</span>
  <span class="keyword">end</span>

  <span class="function"><span class="keyword">def</span> </span><span class="keyword">self</span>.down
    remove_attachment <span class="symbol">:users</span>, <span class="symbol">:avatar</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><h3 id="new_view">new view</h3><pre><code><span class="xml"></span>&lt;%=<span class="ruby"> form_for <span class="variable">@user</span>, <span class="symbol">:url</span> =&gt; users_path, <span class="symbol">:html</span> =&gt; { <span class="symbol">:multipart</span> =&gt; <span class="keyword">true</span> } <span class="keyword">do</span> |form| </span>%&gt;<span class="xml">
 </span>&lt;%=<span class="ruby"> form.file_field <span class="symbol">:avatar</span> </span>%&gt;<span class="xml">
</span>&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;<span class="xml"></span>
</code></pre><h3 id="controller">controller</h3><pre><code>def <span class="operator"><span class="keyword">create</span>
  @<span class="keyword">user</span> = <span class="keyword">User</span>.<span class="keyword">create</span>( user_params )
<span class="keyword">end</span>

private

# <span class="keyword">Use</span> strong_parameters <span class="keyword">for</span> attribute whitelisting
# Be sure <span class="keyword">to</span> <span class="keyword">update</span> your <span class="keyword">create</span>() <span class="keyword">and</span> <span class="keyword">update</span>() controller methods.

def user_params
  params.require(:<span class="keyword">user</span>).permit(:avatar)
<span class="keyword">end</span></span>
</code></pre><h3 id="show_view">show view</h3><pre><code>&lt;<span class="variable">%=</span> image_tag <span class="variable">@user</span>.avatar.url <span class="variable">%&gt;</span>
&lt;<span class="variable">%=</span> image_tag <span class="variable">@user</span>.avatar.url(:medium) <span class="variable">%&gt;</span>
&lt;<span class="variable">%=</span> image_tag <span class="variable">@user</span>.avatar.url(:thumb) <span class="variable">%&gt;</span>
</code></pre><h3 id="删除">删除</h3><p>把属性设置为nil，然后保存即可</p>
<pre><code><span class="variable">@user</span>.avatar = nil
<span class="variable">@user</span>.save
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>参考：<a href="https://github.com/thoughtbot/paperclip" target="_blank" rel="external">https://github.com/thoughtbot/paperclip</a></p>
<h2 i]]>
    </summary>
    
      <category term="Ruby On Rails" scheme="http://0x520.com/categories/Ruby-On-Rails/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rails中使用devise进行用户认证]]></title>
    <link href="http://0x520.com/2015/05/24/rails/4/"/>
    <id>http://0x520.com/2015/05/24/rails/4/</id>
    <published>2015-05-24T08:02:00.000Z</published>
    <updated>2015-05-24T11:44:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户认证">用户认证</h1><p>编辑Gemfile加上</p>
<pre><code><span class="title">gem</span> <span class="string">'devise'</span>
</code></pre><p>輸入bundle install安裝此套件<br>輸入rails g devise:install產生devise設定檔<br>編輯 config/environments/development.rb  加入</p>
<pre><code>config.action_mailer.default_url_options  = { <span class="symbol">host:</span> <span class="string">'localhost'</span>, <span class="symbol">port:</span> <span class="number">3000</span> }
config.action_mailer.delivery_method      = <span class="symbol">:smtp</span>
config.action_mailer.smtp_settings        = {
    <span class="symbol">:address</span>        =&gt; <span class="string">"smtp.exmail.qq.com"</span>,
    <span class="symbol">:port</span>           =&gt; <span class="number">25</span>,
    <span class="symbol">:domain</span>         =&gt; <span class="string">"morningtec.cn"</span>,
    <span class="symbol">:authentication</span> =&gt; <span class="symbol">:login</span>,
    <span class="symbol">:user_name</span>      =&gt; <span class="string">"huangsz@morningtec.cn"</span>,
    <span class="symbol">:password</span>       =&gt; <span class="string">"thepassword"</span>
}
</code></pre><p>编辑devise.rb 修改：</p>
<pre><code>config<span class="class">.mailer_sender</span> = <span class="string">'huangsz@morningtec.cn'</span>
</code></pre><p>编辑app/views/layouts/application.html.erb，加入</p>
<pre><code> <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"notice"</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">notice</span> %&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"alert"</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">alert</span> %&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>輸入<code>rails g devise user</code>產生 User model 及 Migration  </p>
<p>如果需要E-mail驗證功能，可以編輯app/models/user.rb和migration將confirmable功能打開</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="inheritance">&lt; <span class="parent">ActiveRecord::Base</span></span></span>
  <span class="comment"># Include default devise modules. Others available are:</span>
  <span class="comment"># :confirmable, :lockable, :timeoutable and :omniauthable</span>
  devise <span class="symbol">:database_authenticatable</span>, <span class="symbol">:registerable</span>,
         <span class="symbol">:recoverable</span>, <span class="symbol">:rememberable</span>, <span class="symbol">:trackable</span>, <span class="symbol">:validatable</span>, 
         <span class="symbol">:confirmable</span>,<span class="symbol">:lockable</span>
<span class="keyword">end</span>
</code></pre><p>輸入<code>rails generate devise:views</code>產生樣板，這會包括有註冊、登入、忘記密碼、Email等等頁面，放在app/views/devise目錄下。</p>
<p>輸入<code>rake db:migrate</code>建立資料表</p>
<h1 id="集成cancan和rolify权限管理">集成cancan和rolify权限管理</h1><p>cancan提供对资源的授权控制。例如，在视图中使用can?方法来决定是否显示某个页面元素。如果系统角色非常简单，那么cancan还在代码中直接指定常量就可以支持，具体操作可以参考官方文档。但要提供复杂的角色管理，最好的方案，还是在devise基础上再集成cancan+rolify。</p>
<p>1.修改Gemfile，并再次运行bundle install</p>
<pre><code><span class="title">gem</span> <span class="string">'cancan'</span>
gem <span class="string">'rolify'</span>
</code></pre><p>2.创建cancan的Ability和rolify的Role</p>
<pre><code>rails <span class="keyword">generate</span> cancan:ability
rails <span class="keyword">generate</span> rolify Role User
rake <span class="keyword">db</span>:migrate
</code></pre><p>3.定制devise用户注册事件，可以在注册时赋予用户rolify角色，例如，下面的代码为首个用户赋予admin角色：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> <span class="inheritance">&lt; <span class="parent">ActionController::Base</span></span></span>
  <span class="function"><span class="keyword">def</span> </span>after_sign_in_path_for(resource)
    <span class="keyword">if</span> resource.is_a?(<span class="constant">User</span>)
      <span class="keyword">if</span> <span class="constant">User</span>.count == <span class="number">1</span>
        resource.add_role <span class="string">'admin'</span>
      <span class="keyword">end</span>
      resource
    <span class="keyword">end</span>
    root_path
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>4.使用cancan可以为rolify中建立的角色分配授权资源，例如我们为允许admin角色的用户分配针对所有控制类的”manage”资源，而其他用户分配”read”资源：</p>
<pre><code><span class="function"><span class="keyword">def</span> </span>initialize(user)
    <span class="keyword">if</span> user.has_role? <span class="symbol">:admin</span>
      can <span class="symbol">:manage</span>, <span class="symbol">:all</span>
    <span class="keyword">else</span>
      can <span class="symbol">:read</span>, <span class="symbol">:all</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>5.以上已经实现了“用户－角色－权限”的三层权限模型，在view中就可以使用了。例如，在Home#index页面中增加如下代码：</p>
<pre><code><span class="xml"><span class="comment">&lt;!--权限管理--&gt;</span>
</span>&lt;%<span class="ruby"> <span class="keyword">if</span> user_signed_in? </span>%&gt;<span class="xml">
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>The user is loged in.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    </span>&lt;%<span class="ruby"> <span class="keyword">if</span> can? <span class="symbol">:manage</span>, <span class="symbol">:Articles</span> </span>%&gt;<span class="xml">
      </span>&lt;%=<span class="ruby"> link_to <span class="string">"Articles"</span>, articles_path </span>%&gt;<span class="xml">
    </span>&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;<span class="xml">
</span>&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;<span class="xml"></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="用户认证">用户认证</h1><p>编辑Gemfile加上</p>
<pre><code><span class="title">gem</span> <span class="string">'devise'</span>
</code></pre><p>輸入b]]>
    </summary>
    
      <category term="Ruby On Rails" scheme="http://0x520.com/categories/Ruby-On-Rails/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rails 中使用bootstrap]]></title>
    <link href="http://0x520.com/2015/05/24/rails/3/"/>
    <id>http://0x520.com/2015/05/24/rails/3/</id>
    <published>2015-05-24T07:02:00.000Z</published>
    <updated>2015-05-24T11:44:06.000Z</updated>
    <content type="html"><![CDATA[<p>如果需要自定义less的话，请参考 <a href="http://www.rubydoc.info/gems/twitter-bootstrap-rails/3.2.0" target="_blank" rel="external">http://www.rubydoc.info/gems/twitter-bootstrap-rails/3.2.0</a></p>
<h2 id="Installing_the_CSS_stylesheets">Installing the CSS stylesheets</h2><p>If you don’t need to customize the stylesheets using Less, the only gem you need is the twitter-bootstrap-rails gem:</p>
<pre><code><span class="title">gem</span> <span class="string">"twitter-bootstrap-rails"</span>
</code></pre><p>After running bundle install, run the generator:</p>
<pre><code>rails generate <span class="string">bootstrap:</span>install <span class="keyword">static</span>
</code></pre><p>Use <code>bundle show [gemname]</code> to see where a bundled gem is installed.</p>
<h2 id="Generating_layouts_and_views">Generating layouts and views</h2><p>You can run following generators to get started with Bootstrap quickly.</p>
<p>Layout (generates Bootstrap compatible layout) - (Haml and Slim supported)</p>
<p>Usage:</p>
<pre><code>rails <span class="keyword">g</span> <span class="keyword">bootstrap</span>:layout [LAYOUT_NAME]
</code></pre><p>Themed (generates Bootstrap compatible scaffold views.) - (Haml and Slim supported)</p>
<p>Usage:</p>
<pre><code>rails <span class="keyword">g</span> <span class="keyword">bootstrap</span>:themed [RESOURCE_NAME]
</code></pre><p>Example:</p>
<pre><code>rails <span class="keyword">g</span> scaffold <span class="keyword">Post</span> title:string description:text
rake <span class="keyword">db</span>:migrate
rails <span class="keyword">g</span> <span class="keyword">bootstrap</span>:themed Posts
</code></pre><p>Notice the plural usage of the resource to generate bootstrap:themed.</p>
<h2 id="解决：_couldn’t_find_file_‘twitter-bootstrap-static/bootstrap’_的问题">解决： couldn’t find file ‘twitter-bootstrap-static/bootstrap’ 的问题</h2><p>检查/Library/Ruby/Gems/2.0.0/gems/twitter-bootstrap-rails-3.2.0的用户权限</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果需要自定义less的话，请参考 <a href="http://www.rubydoc.info/gems/twitter-bootstrap-rails/3.2.0" target="_blank" rel="external">http://www.rubydoc.]]>
    </summary>
    
      <category term="Ruby On Rails" scheme="http://0x520.com/categories/Ruby-On-Rails/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby on Rails 开发起步走]]></title>
    <link href="http://0x520.com/2015/05/23/rails/2/"/>
    <id>http://0x520.com/2015/05/23/rails/2/</id>
    <published>2015-05-23T08:02:00.000Z</published>
    <updated>2015-05-24T11:44:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本命令">基本命令</h1><p>创建一个rials的demo程序</p>
<pre><code>rails <span class="keyword">new</span> demo --<span class="keyword">skip</span>-test-<span class="keyword">unit</span>
</code></pre><p>启动web服务器</p>
<pre><code>rails <span class="keyword">server</span>  或 rails s
</code></pre><p>创建控制器</p>
<pre><code>rails <span class="keyword">generate</span> controller welcome
或
rails <span class="keyword">g</span> controller welcome
</code></pre><p>创建页面上的链接：</p>
<pre><code>&lt;<span class="variable">%=</span> link_to <span class="string">'Hello!'</span>, welcome_say_hello_path <span class="variable">%&gt;</span>
&lt;<span class="variable">%=</span> link_to <span class="string">'Hello!'</span>, welcome_say_hello_path <span class="variable">%&gt;</span>
</code></pre><p>创建数据库</p>
<pre><code><span class="tag">rake</span> <span class="rule"><span class="attribute">db</span>:<span class="value">create</span></span>
</code></pre><h2 id="创建一个简单的CRUD应用">创建一个简单的CRUD应用</h2><p>创建crud程序框架</p>
<pre><code>rails g scaffold <span class="keyword">person</span> name:string bio:text birthday:date
</code></pre><p>执行数据库迁移：</p>
<pre><code><span class="tag">rake</span> <span class="rule"><span class="attribute">db</span>:<span class="value">migrate </span></span>
</code></pre><p>访问：<a href="http://localhost:3000/people" target="_blank" rel="external">http://localhost:3000/people</a></p>
<p>一个最简单的CRUD应用程序开发完毕！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基本命令">基本命令</h1><p>创建一个rials的demo程序</p>
<pre><code>rails <span class="keyword">new</span> demo --<span class="keyword">skip</span>-te]]>
    </summary>
    
      <category term="Ruby On Rails" scheme="http://0x520.com/categories/Ruby-On-Rails/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ruby on Rails 基础知识整理]]></title>
    <link href="http://0x520.com/2015/05/23/rails/1/"/>
    <id>http://0x520.com/2015/05/23/rails/1/</id>
    <published>2015-05-23T07:02:00.000Z</published>
    <updated>2015-05-24T11:44:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="RubyGems簡介">RubyGems簡介</h2><p>RubyGems是Ruby的套件管理系統，讓你輕易安裝及管理Ruby函式庫。你可以在RubyGems上找到所有的Ruby開源套件。另外，讀者如果想找Ruby或Rails有哪些好用的套件，也可以瀏覽看看The Ruby Toolbox，這個站依照套件的熱門程度排序，非常方便。</p>
<h3 id="常用指令">常用指令</h3><pre><code>gem -v 告訴你 RubyGems 的版本
gem <span class="operator"><span class="keyword">update</span> <span class="comment">--system 升級RubyGems的版本</span>
gem <span class="keyword">install</span> gem_name 安裝某個套件
gem list 列出安裝的套件
gem <span class="keyword">update</span> gem_name 更新最新版本
gem <span class="keyword">update</span> 更新所有你安裝的Gems
gem <span class="keyword">install</span> -v x.x.x gemname 安裝特定版本
gem <span class="keyword">uninstall</span> gem_name 反安裝</span>
</code></pre><p>執行gem install gem_name的時候，它會在安裝完之後，自動產生此套件的RDoc和ri文件。不過有鑑於目前網路發達，往往直接 Google或是在套件官網就可以查詢到文件，所以其實不太需要在本地端機器產生文件，況且安裝的時間耗時又佔硬碟空間。要省略這個步驟，有兩種方式：<br>每次安裝時，加上以下參數：</p>
<pre><code>$ gem install gem_name --<span class="keyword">no</span>-<span class="keyword">ri</span> --<span class="keyword">no</span>-rdoc
</code></pre><p>或是新增一個<code>~/.gemrc</code>檔案內容如下，預設就不產生文件：</p>
<pre><code><span class="comment">gem:</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">no</span><span class="literal">-</span><span class="comment">ri</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">no</span><span class="literal">-</span><span class="comment">rdoc</span>
</code></pre><h2 id="Bundle简介">Bundle简介</h2><p>Rails 3中引入Bundle来管理项目中所有gem依赖，该命令只能在一个含有Gemfile的目录下执行，如rails 3项目的根目录。</p>
<p><strong>关于Gemfile和Gemfile.lock</strong></p>
<p>所有Ruby项目的信赖包都在Gemfile中进行配置，不再像以往那样，通过require来查找。Rails 3中如果需要require某个gem包，必须通过修改Gemfile文件来管理。</p>
<p>Gemfile.lock则用来记录本机目前所有依赖的Ruby Gems及其版本。所以强烈建议将该文件放入版本控制器，从而保证大家基于同一环境下工作。</p>
<p>Bundle命令详解：</p>
<pre><code><span class="comment"># 显示所有的依赖包</span>
<span class="variable">$ </span>bundle show
<span class="comment"># 显示指定gem包的安装位置</span>
<span class="variable">$ </span>bundle show [gemname]
<span class="comment"># 检查系统中缺少那些项目以来的gem包</span>
<span class="comment"># 注：如果系统中存在所有项目以来的包，则会输出：The Gemfile's dependencies are satisfied</span>
<span class="variable">$ </span>bundle check
<span class="comment"># 安装项目依赖的所有gem包</span>
<span class="comment"># 注：此命令会尝试更新系统中已存在的gem包</span>
<span class="variable">$ </span>bundle install
<span class="comment"># 安装指定的gem包</span>
<span class="variable">$ </span>bundle install [gemname]
<span class="comment"># 更新系统中存在的项目依赖包，并同时更新项目Gemfile.lock文件</span>
<span class="variable">$ </span>bundle update
<span class="comment"># 更新系统中指定的gem包信息，并同时更新项目Gemfile.lock中指定的包信息</span>
<span class="variable">$ </span>bundle update [gemname]
<span class="comment"># 向项目中添加新的gem包引用</span>
<span class="variable">$ </span>gem [gemname], [ver]
<span class="comment"># 你还可以指定包依赖关系</span>
<span class="variable">$ </span>gem [gemname], <span class="symbol">:require</span> =&gt; [dependence_gemname]
<span class="comment"># 你甚至还可以指定gem包的git源</span>
<span class="variable">$ </span>gem [gemname], <span class="symbol">:git</span> =&gt; [git_source_url]
<span class="comment"># 锁定当前环境</span>
<span class="comment"># 可以使用bundle lock来锁定当前环境，这样便不能通过bundle update来更新依赖包的版本，保证了统一的环境</span>
<span class="variable">$ </span>bundle lock
<span class="comment"># 解除锁定</span>
<span class="variable">$ </span>bundle unlock
<span class="comment"># 打包当装环境</span>
<span class="comment"># bundle package会把当前所有信赖的包都放到 ./vendor/cache/ 目录下，发布时可用来保证包版本的一致性。</span>
<span class="variable">$ </span>bundle package
</code></pre><h2 id="Rake简介">Rake简介</h2><p>Rake 是一套類似 Make 的 Builder 工具，讓我們可以撰寫一些腳本任務，並且很方便設定各個任務的相依性。在 Rails 之中就內建了許多 rake 指令，除了你已經使用過的 rake db:migrate 之外，還有例如：</p>
<pre><code>rake <span class="keyword">db</span>:migrate
rake <span class="keyword">db</span>:<span class="keyword">drop</span>
rake tmp:<span class="keyword">clear</span>
rake <span class="keyword">notes</span>
</code></pre><p>你可以輸入 <code>rake -T</code> 看到所有的 rake 指令。而要在 Rails 環境中撰寫 Rake，請將附檔名為 .rake 的檔案放在 lib/tasks 目錄下即可，例如：</p>
<pre><code>/lib/tasks/dev.rake

namespace <span class="symbol">:dev</span> <span class="keyword">do</span>

  desc <span class="string">"Rebuild system"</span>
  task <span class="symbol">:build</span> =&gt; [<span class="string">"tmp:clear"</span>, <span class="string">"log:clear"</span>, <span class="string">"db:drop"</span>, <span class="string">"db:create"</span>, <span class="string">"db:migrate"</span>, <span class="symbol">:setup</span> ]

  desc <span class="string">"Setup system data"</span>
  task <span class="symbol">:setup</span> =&gt; <span class="symbol">:environment</span> <span class="keyword">do</span>
      puts <span class="string">"Create system user"</span>
      u = <span class="constant">User.</span>new( <span class="symbol">:login</span> =&gt; <span class="string">"root"</span>, <span class="symbol">:password</span> =&gt; <span class="string">"password"</span>, <span class="symbol">:email</span> =&gt; <span class="string">"root@example.com"</span>, <span class="symbol">:name</span> =&gt; <span class="string">"管理員"</span>)
      u.is_admin = <span class="keyword">true</span>
      u.save!
  <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre><p>透過執行 rake dev:build，就會自動清除 log 檔案，砍掉資料庫，執行 migrate，然後執行 rake dev:setup 建立一個使用者。</p>
<p>其他常見的使用情境包括：</p>
<ol>
<li>修正上線的資料，這樣部署到Production後，可以用來執行 </li>
<li>建立開發用的假資料 </li>
<li>搭配排成工具使用，例如每天凌晨三點寄出通知信、每週一產生報表等等</li>
</ol>
<p>更多介紹可以參考 <a href="http://codequietly.com/2010/6/rake-tasks-101" target="_blank" rel="external">http://codequietly.com/2010/6/rake-tasks-101</a> 和 <a href="http://jasonseifer.com/2010/04/06/rake-tutorial" target="_blank" rel="external">http://jasonseifer.com/2010/04/06/rake-tutorial</a> 兩篇文章。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="RubyGems簡介">RubyGems簡介</h2><p>RubyGems是Ruby的套件管理系統，讓你輕易安裝及管理Ruby函式庫。你可以在RubyGems上找到所有的Ruby開源套件。另外，讀者如果想找Ruby或Rails有哪些好用的套件，也可以瀏覽看看Th]]>
    </summary>
    
      <category term="Ruby On Rails" scheme="http://0x520.com/categories/Ruby-On-Rails/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android WebView中加载本地资源的解决办法]]></title>
    <link href="http://0x520.com/2015/05/12/issue/2/"/>
    <id>http://0x520.com/2015/05/12/issue/2/</id>
    <published>2015-05-11T16:00:00.000Z</published>
    <updated>2015-05-23T03:37:01.000Z</updated>
    <content type="html"><![CDATA[<p>Android上的WebView真是个好东西呀，对我这种不会开发安卓程序的代码搬运工来说绝对是一剂良药！我完全可以用H5写伪安卓程序嘛~</p>
<p>写网页的人都知道，有些CSS/JS/Images是不会改变的，比如Bootstrap.css / JQuery.js 等等。那么问题来了，我们不想每次都要加载这些不会改变的库文件怎么办？</p>
<p>我当然会告诉你怎么办！！！！那就是我研究的【注入大法】：</p>
<p>第一步：将资源拷贝到assets目录</p>
<p>第二步：给需要注入的资源文件在url上做一个标志，当然，你也可以不做，只要你在安卓端可以判断出来即可。</p>
<pre><code>&lt;link <span class="variable">rel=</span><span class="string">"stylesheet"</span> <span class="variable">href=</span><span class="string">"[inject]public/css/bootstrap.min.css"</span> <span class="variable">type=</span><span class="string">"text/css"</span> <span class="variable">media=</span><span class="string">"screen"</span> <span class="variable">title=</span><span class="string">"no title"</span> <span class="variable">charset=</span><span class="string">"utf-8"</span>&gt;
&lt;link <span class="variable">rel=</span><span class="string">"stylesheet"</span> <span class="variable">href=</span><span class="string">"[inject]public/css/bootstrap-theme.min.css"</span> <span class="variable">type=</span><span class="string">"text/css"</span> <span class="variable">media=</span><span class="string">"screen"</span> <span class="variable">title=</span><span class="string">"no title"</span> <span class="variable">charset=</span><span class="string">"utf-8"</span>&gt;
&lt;script <span class="variable">type=</span><span class="string">"text/javascript"</span> <span class="variable">src=</span><span class="string">"[inject]public/js/zipto/1.1.6/zepto.min.js"</span>&gt;&lt;/script&gt;
&lt;script <span class="variable">type=</span><span class="string">"text/javascript"</span> <span class="variable">src=</span><span class="string">"[inject]public/js/modules/md5.min.js"</span>&gt;&lt;/script&gt;
</code></pre><p>第三步：拦截将要注入的文件，读取本地文件即可。</p>
<pre><code>webview.setWebViewClient(<span class="keyword">new</span> WebViewClient() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, String url)</span> </span>{
        <span class="comment">//System.out.println("WebResourceResponse::"+url);</span>
        <span class="keyword">if</span>(url.contains(<span class="string">"[inject]"</span>)){
            String localPath = url.replaceFirst(<span class="string">"^http.*inject\\]"</span>,<span class="string">""</span>);
            System.out.println(<span class="string">"LocalPath::"</span>+localPath);
            <span class="keyword">try</span> {
                InputStream is = getApplicationContext().getAssets().open(localPath);
                <span class="keyword">return</span> <span class="keyword">new</span> WebResourceResponse(<span class="string">"text/javascript"</span>, <span class="string">"UTF-8"</span>, is);
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
                <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">shouldInterceptRequest</span><span class="params">(view, url)</span></span>;
            }
        } <span class="keyword">else</span> {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">shouldInterceptRequest</span><span class="params">(view, url)</span></span>;
        }
    }
});
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Android上的WebView真是个好东西呀，对我这种不会开发安卓程序的代码搬运工来说绝对是一剂良药！我完全可以用H5写伪安卓程序嘛~</p>
<p>写网页的人都知道，有些CSS/JS/Images是不会改变的，比如Bootstrap.css / JQuery.js 等等]]>
    </summary>
    
      <category term="Android" scheme="http://0x520.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第二十一篇：对象作为函数参数或返回值]]></title>
    <link href="http://0x520.com/2015/04/21/reverse/21/"/>
    <id>http://0x520.com/2015/04/21/reverse/21/</id>
    <published>2015-04-20T16:00:00.000Z</published>
    <updated>2015-05-23T03:41:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1、对象作为函数参数">1、对象作为函数参数</h2><p>下面是一段<code>对象作为参数</code>的代码片段：</p>
<pre><code>class CTest{
<span class="label">public:</span>
    <span class="keyword">int</span> m_nOne<span class="comment">;</span>
    <span class="keyword">int</span> m_nTwo<span class="comment">;</span>
}<span class="comment">;</span>

void ShowFunTest(CTest <span class="keyword">Test</span>)
{
    printf(<span class="string">"%d,%d \r\n"</span>,<span class="keyword">Test</span>.m_nOne,<span class="keyword">Test</span>.m_nTwo)<span class="comment">;</span>
}

<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest <span class="keyword">Test</span><span class="comment">;</span>
    <span class="keyword">Test</span>.m_nOne = <span class="number">1</span><span class="comment">;</span>
    <span class="keyword">Test</span>.m_nTwo = <span class="number">2</span><span class="comment">;</span>
    ShowFunTest(<span class="keyword">Test</span>)<span class="comment">;</span>
    getchar()<span class="comment">;</span>
}
</code></pre><a id="more"></a>
<p>_tmain反汇编代码片段如下:</p>
<pre><code>    CTest <span class="keyword">Test</span><span class="comment">;</span>
    <span class="keyword">Test</span>.m_nOne = <span class="number">1</span><span class="comment">;                            </span>
00DD1A5E  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="keyword">Test</span>],<span class="number">1</span>        <span class="comment">;给第一个成员变量赋值</span>
    <span class="keyword">Test</span>.m_nTwo = <span class="number">2</span><span class="comment">;</span>
00DD1A65  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">8</span>],<span class="number">2</span>       <span class="comment">;给第二个成员变量赋值</span>
    ShowFunTest(<span class="keyword">Test</span>)<span class="comment">;</span>
00DD1A6C  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">8</span>]     <span class="comment">;第二个成员变量作为参数</span>
00DD1A6F  <span class="keyword">push</span>        <span class="number">eax</span>  
00DD1A70  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="keyword">Test</span>]      <span class="comment">;第一个成员变量作为参数</span>
00DD1A73  <span class="keyword">push</span>        <span class="number">ecx</span>  
00DD1A74  <span class="keyword">call</span>        ShowFunTest (<span class="number">0DD11E5h</span>)    <span class="comment">;调用ShowFunTest函数</span>
00DD1A79  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
    getchar()<span class="comment">;</span>
</code></pre><p>通过反汇编可以看出，对象作为参数时，是将对象的成员变量逐个复制，然后压栈，作为参数传递到函数中，并非将对象的首地址作为参数。</p>
<h3 id="1-1、含有数组成员变量的对象作为参数">1.1、含有数组成员变量的对象作为参数</h3><p>但是，当类的体积过大时，或者有数组类型的成员变量时，会将数组的首地址压栈吗？</p>
<pre><code><span class="keyword">class</span> CTest{
<span class="keyword">public</span>:
    <span class="keyword">int</span> m_nOne;
    <span class="keyword">int</span> m_nTwo;
    <span class="keyword">char</span> m_szName[<span class="number">20</span>]; <span class="comment">//定义数组类型的成员变量</span>
};
<span class="function"><span class="keyword">void</span> <span class="title">ShowFunTest</span><span class="params">(CTest Test)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"%d,%d,%s \r\n"</span>,Test.m_nOne,Test.m_nTwo,Test.m_szName);
}
<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest Test;
    Test.m_nOne = <span class="number">1</span>;
    Test.m_nTwo = <span class="number">2</span>;
    <span class="built_in">strcpy</span>(Test.m_szName,<span class="string">"This is an Array"</span>);
    ShowFunTest(Test);
    getchar();
}
</code></pre><p>反汇编代码如下：</p>
<p><img src="/uploads/2014/07/3312030032.png" alt="1.png"></p>
<p>通过上图，可以看出，对数组内容也进行拷贝。</p>
<h3 id="1-2、对象拷贝引起的错误">1.2、对象拷贝引起的错误</h3><p>对象作为函数的参数，但是当函数退出时，复制的对象作为函数内的局部变量，将会被销毁。 当析构函数存在时，则会调用析构函数，这里有可能会引起错误。</p>
<pre><code><span class="keyword">class</span> CMyString{
<span class="keyword">public</span>:
    CMyString()
    {
        m_pString = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];
        <span class="keyword">if</span>(m_pString == NULL){
            <span class="keyword">return</span>;
        }
        <span class="built_in">strcpy</span>(m_pString,<span class="string">"Hello"</span>);
    }
    ~CMyString()
    {
        <span class="keyword">if</span> (m_pString!=NULL)
        {
            <span class="keyword">delete</span> m_pString;
            m_pString = NULL;
        }
    }
    <span class="keyword">char</span>* GetString()
    {
        <span class="keyword">return</span> m_pString;
    }
<span class="keyword">private</span>:
    <span class="keyword">char</span> * m_pString;
};

<span class="function"><span class="keyword">void</span> <span class="title">ShowMyString</span><span class="params">(CMyString MyString)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"%s \r\n"</span>,MyString.GetString());
}

<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CMyString MyString;
    ShowMyString(MyString);
}
</code></pre><p>_tmain函数反汇编：</p>
<pre><code>    CMyString MyString<span class="comment">;</span>
<span class="number">0118159D</span>  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>-<span class="number">14h</span>]                    <span class="comment">;获得对象首地址</span>
011815A0  <span class="keyword">call</span>        CMyString::CMyString (<span class="number">11810C8h</span>)  <span class="comment">;调用构造函数</span>
011815A5  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0</span>              <span class="comment">;记录同一作用域内该类的对象个</span>
    ShowMyString(MyString)<span class="comment">;</span>
011815AC  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>]          <span class="comment">;MyString对象的首地址(m_pString地址)</span>
011815AF  <span class="keyword">push</span>        <span class="number">eax</span>                              <span class="comment">;首地址入栈</span>
011815B0  <span class="keyword">call</span>        ShowMyString (<span class="number">118115Eh</span>)  
011815B5  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">4</span>  
}
011815B8  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0FFFFFFFFh</span>     <span class="comment">;对象被释放，修改对象个数</span>
011815BF  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>-<span class="number">14h</span>]                    <span class="comment">;取对象首地址</span>
011815C2  <span class="keyword">call</span>        CMyString::~CMyString (<span class="number">118116Dh</span>) <span class="comment">;调用析构函数</span>
011815C7  <span class="keyword">xor</span>         <span class="number">eax</span>,<span class="number">eax</span>  
011815C9  <span class="keyword">push</span>        <span class="number">edx</span>  
011815CA  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="literal">ebp</span>  
011815CC  <span class="keyword">push</span>        <span class="number">eax</span>  
...略...
</code></pre><p>ShowMyString函数部分反汇编代码：</p>
<pre><code>void ShowMyString(CMyString MyString)
{
...略... 
    printf(<span class="string">"%s \r\n"</span>,MyString.GetString())<span class="comment">;</span>
<span class="number">01181424</span>  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>+<span class="number">8</span>]                           <span class="comment">;对象首地址</span>
<span class="number">01181427</span>  <span class="keyword">call</span>        CMyString::GetString (<span class="number">118101Eh</span>)       <span class="comment">;调用GetString函数</span>
0118142C  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
0118142E  <span class="keyword">push</span>        <span class="number">eax</span>                                   <span class="comment">;m_pString地址，入栈</span>
0118142F  <span class="keyword">push</span>        offset string <span class="string">"%s \r\n"</span> (<span class="number">1186830h</span>)    <span class="comment">;printf</span>
<span class="number">01181434</span>  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">11892DCh</span>)]  
0118143A  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
<span class="number">0118143D</span>  <span class="keyword">cmp</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
0118143F  <span class="keyword">call</span>        @ILT+<span class="number">330</span>(__RTC_CheckEsp) (<span class="number">118114Fh</span>)  
}
<span class="number">01181444</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0FFFFFFFFh</span>          <span class="comment">;修改作用域对象的个数</span>
0118144B  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>+<span class="number">8</span>]                           <span class="comment">;取得对象的首地址</span>
0118144E  <span class="keyword">call</span>        CMyString::~CMyString (<span class="number">118116Dh</span>)      <span class="comment">;调用析构函数</span>
<span class="number">01181453</span>  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>]  
<span class="number">01181456</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">fs</span>:[<span class="number">0</span>],<span class="number">ecx</span>  
<span class="number">0118145D</span>  <span class="keyword">pop</span>         <span class="number">ecx</span>  
0118145E  <span class="keyword">pop</span>         <span class="literal">edi</span>  
0118145F  <span class="keyword">pop</span>         <span class="literal">esi</span>  
<span class="number">01181460</span>  <span class="keyword">pop</span>         <span class="number">ebx</span>  
<span class="number">01181461</span>  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">0CCh</span>  
<span class="number">01181467</span>  <span class="keyword">cmp</span>         <span class="literal">ebp</span>,<span class="literal">esp</span>  
<span class="number">01181469</span>  <span class="keyword">call</span>        @ILT+<span class="number">330</span>(__RTC_CheckEsp) (<span class="number">118114Fh</span>)  
0118146E  <span class="keyword">mov</span>         <span class="literal">esp</span>,<span class="literal">ebp</span>  
<span class="number">01181470</span>  <span class="keyword">pop</span>         <span class="literal">ebp</span>  
<span class="number">01181471</span>  <span class="keyword">ret</span>  
</code></pre><p>通过上面反汇编代码看出，在ShowMyString中调用了一次析构函数。如果在_tmain函数这么写：</p>
<pre><code>int _<span class="function">tmain</span>(int argc, _TCHAR* argv<span class="attr_selector">[]</span>)
{
    CMyString MyString;
    <span class="function">ShowMyString</span>(MyString);
    <span class="function">ShowMyString</span>(MyString);
}
</code></pre><p>这里将会调用两次析构函数，在debug模式下，有错误检查，会有错误提示。 </p>
<p>如果是在release模式下，不会对堆中的数据进行检查。如果没有再次申请堆空间，此地址中的数据仍然存在，将会引起程序错误。</p>
<h2 id="2、对象作为函数返回值">2、对象作为函数返回值</h2><p>基本数据类型作为返回值时，可以使用eax来保存返回的结果。但是对象属于自定义类型，寄存器eax无法保存所有的返回数据，那么对象作为返回值应该如何处理呢？</p>
<p>实际上，对象作为返回值与对象作为参数非常类似，对象作为参数时，进入函数前预先将对象使用的栈空间保留出来，并将实参对象中的数据复制到栈空间中，将此栈空间作为函数参数，在函数内部使用。</p>
<p>同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时栈空间中，将这个临时栈空间的首地址返回。</p>
<p>测试代码：</p>
<pre><code><span class="keyword">class</span> CReturn{
<span class="keyword">public</span>:
    <span class="keyword">int</span> m_nNumber;
    <span class="keyword">int</span> m_nArray[<span class="number">10</span>];
};

<span class="function">CReturn <span class="title">GetCReturn</span><span class="params">()</span></span>{
    CReturn RetObj;
    RetObj.m_nNumber = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)
    {
        RetObj.m_nArray[i] = i+<span class="number">1</span>;
    }
    <span class="keyword">return</span> RetObj;
}

<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CReturn obj;
    obj = GetCReturn();
    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d"</span>,obj.m_nNumber,obj.m_nArray[<span class="number">0</span>],obj.m_nArray[<span class="number">9</span>]);
}
</code></pre><p>_tmain 反汇编分析：</p>
<pre><code><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
013D1460  <span class="keyword">push</span>        <span class="literal">ebp</span>  
013D1461  <span class="keyword">mov</span>         <span class="literal">ebp</span>,<span class="literal">esp</span>  
013D1463  <span class="keyword">sub</span>         <span class="literal">esp</span>,<span class="number">160h</span>                     <span class="comment">;预留栈空间 </span>
013D1469  <span class="keyword">push</span>        <span class="number">ebx</span>  
013D146A  <span class="keyword">push</span>        <span class="literal">esi</span>  
013D146B  <span class="keyword">push</span>        <span class="literal">edi</span>  
013D146C  <span class="keyword">lea</span>         <span class="literal">edi</span>,[<span class="literal">ebp</span>-<span class="number">160h</span>]               <span class="comment">;edi=esp=栈顶</span>
013D1472  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">58h</span>                      <span class="comment">;初始化预留的占空间</span>
013D1477  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="number">0CCCCCCCCh</span>               <span class="comment">;初始化预留的占空间</span>
013D147C  <span class="keyword">rep</span> stos    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>]           <span class="comment">;初始化预留的占空间</span>
013D147E  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [___security_cookie (<span class="number">13D7000h</span>)]  
013D1483  <span class="keyword">xor</span>         <span class="number">eax</span>,<span class="literal">ebp</span>  
013D1485  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">eax</span>  
    CReturn obj<span class="comment">;</span>
    obj = GetCReturn()<span class="comment">;</span>
013D1488  <span class="keyword">lea</span>         <span class="number">eax</span>,[<span class="literal">ebp</span>-<span class="number">128h</span>]               <span class="comment">;返回对象的首地址</span>
013D148E  <span class="keyword">push</span>        <span class="number">eax</span>                          <span class="comment">;返回对象的首地址入栈，保存返回对象的数据</span>
013D148F  <span class="keyword">call</span>        GetCReturn (<span class="number">13D1190h</span>)  
013D1494  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">4</span>  
013D1497  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">0Bh</span>                      <span class="comment">;0B=11=循环次数</span>
013D149C  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="number">eax</span>                      <span class="comment">;esi=eax=返回对象的首地址</span>
013D149E  <span class="keyword">lea</span>         <span class="literal">edi</span>,[<span class="literal">ebp</span>-<span class="number">15Ch</span>]               <span class="comment">;临时对象的首地址</span>
013D14A4  <span class="keyword">rep</span> movs    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>],<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>]<span class="comment">;复制4*11个字节（返回对象赋值给临时对象）</span>
013D14A6  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">0Bh</span>                      <span class="comment">;0B=11=循环次数</span>
013D14AB  <span class="keyword">lea</span>         <span class="literal">esi</span>,[<span class="literal">ebp</span>-<span class="number">15Ch</span>]               <span class="comment">;临时对象首地址(ebp-15Ch)</span>
013D14B1  <span class="keyword">lea</span>         <span class="literal">edi</span>,[<span class="literal">ebp</span>-<span class="number">34h</span>]                <span class="comment">;obj对象首地址(ebp-34h)</span>
013D14B4  <span class="keyword">rep</span> movs    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>],<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>]<span class="comment">;临时对象赋值给obj</span>
    printf(<span class="string">"%d,%d,%d"</span>,obj.m_nNumber,obj.m_nArray[<span class="number">0</span>],obj.m_nArray[<span class="number">9</span>])<span class="comment">;</span>
013D14B6  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
013D14B8  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>]  
013D14BB  <span class="keyword">push</span>        <span class="number">eax</span>  
013D14BC  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">30h</span>]  
013D14BF  <span class="keyword">push</span>        <span class="number">ecx</span>  
013D14C0  <span class="keyword">mov</span>         <span class="number">edx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">34h</span>]  
013D14C3  <span class="keyword">push</span>        <span class="number">edx</span>  
013D14C4  <span class="keyword">push</span>        offset string <span class="string">"%d,%d,%d"</span> (<span class="number">13D5830h</span>)  
013D14C9  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">13D82B0h</span>)]  
013D14CF  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">10h</span>  
013D14D2  <span class="keyword">cmp</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
013D14D4  <span class="keyword">call</span>        @ILT+<span class="number">305</span>(__RTC_CheckEsp) (<span class="number">13D1136h</span>)  
}
</code></pre><p>GetCReturn 反汇编：</p>
<pre><code>CReturn GetCReturn(){
013D1390  <span class="keyword">push</span>        <span class="literal">ebp</span>  
013D1391  <span class="keyword">mov</span>         <span class="literal">ebp</span>,<span class="literal">esp</span>  
013D1393  <span class="keyword">sub</span>         <span class="literal">esp</span>,<span class="number">104h</span>  <span class="comment">;调整栈空间，预留临时返回对象和局部对象内存空间</span>
013D1399  <span class="keyword">push</span>        <span class="number">ebx</span>  
013D139A  <span class="keyword">push</span>        <span class="literal">esi</span>  
013D139B  <span class="keyword">push</span>        <span class="literal">edi</span>  
013D139C  <span class="keyword">lea</span>         <span class="literal">edi</span>,[<span class="literal">ebp</span>-<span class="number">104h</span>]   <span class="comment">;edi=esp=栈顶</span>
013D13A2  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">41h</span>          <span class="comment">;设置循环次数</span>
013D13A7  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="number">0CCCCCCCCh</span>  
013D13AC  <span class="keyword">rep</span> stos    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>]  
013D13AE  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [___security_cookie (<span class="number">13D7000h</span>)]  
013D13B3  <span class="keyword">xor</span>         <span class="number">eax</span>,<span class="literal">ebp</span>  
013D13B5  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">eax</span>  
    CReturn RetObj<span class="comment">;</span>
    RetObj.m_nNumber = <span class="number">0</span><span class="comment">;</span>
013D13B8  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">34h</span>],<span class="number">0</span>    <span class="comment">;m_nNumber赋值为0,这里是RetObj对象的首地址</span>
    for (<span class="keyword">int</span> i=<span class="number">0</span><span class="comment">;i&lt;10;i++)</span>
    {
        RetObj.m_nArray[i] = i+<span class="number">1</span><span class="comment">;</span>
    }
    ..<span class="string">.for</span>循环略...
    return RetObj<span class="comment">;</span>
013D13E6  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">0Bh</span>                  <span class="comment">;设置循环次数=11次</span>
013D13EB  <span class="keyword">lea</span>         <span class="literal">esi</span>,[<span class="literal">ebp</span>-<span class="number">34h</span>]            <span class="comment">;局部对象的首地址</span>
013D13EE  <span class="keyword">mov</span>         <span class="literal">edi</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>+<span class="number">8</span>]    <span class="comment">;返回对象的首地址</span>
013D13F1  <span class="keyword">rep</span> movs    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>],<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>]  
013D13F3  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>+<span class="number">8</span>]    <span class="comment">;返回对象的首地址</span>
}
...略...
</code></pre><p>1、调用GetCReturn之前，编译器将在main函数中申请的返回对象的首地址作为参数入栈。<br>2、函数GetCReturn结束之后，将GetCReturn中定义的局部对象RetObj的数据复制到这个返回对象的空间中。<br>3、将返回对象赋值给obj对象。</p>
<p>这里涉及到<code>返回对象</code>，<code>临时对象</code>，<code>obj对象</code> 这里的临时对象看起来有点多余，直接将返回对象赋值给obj对象不好吗？其实，这是有必要的，因为，C++程序员可能采用这种写法：<code>GetCReturn().m_nNumber</code>，这里是针对返回对象的操作，此时GetCReturn函数已经退出，栈桢也已经关闭，此时操作局部函数的对象已经不合适了。因此，只能由函数调用方准备临时空间，将局部对象赋值给临时对象，到临时空间，</p>
<p>-待发布-</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、对象作为函数参数">1、对象作为函数参数</h2><p>下面是一段<code>对象作为参数</code>的代码片段：</p>
<pre><code>class CTest{
<span class="label">public:</span>
    <span class="keyword">int</span> m_nOne<span class="comment">;</span>
    <span class="keyword">int</span> m_nTwo<span class="comment">;</span>
}<span class="comment">;</span>

void ShowFunTest(CTest <span class="keyword">Test</span>)
{
    printf(<span class="string">"%d,%d \r\n"</span>,<span class="keyword">Test</span>.m_nOne,<span class="keyword">Test</span>.m_nTwo)<span class="comment">;</span>
}

<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest <span class="keyword">Test</span><span class="comment">;</span>
    <span class="keyword">Test</span>.m_nOne = <span class="number">1</span><span class="comment">;</span>
    <span class="keyword">Test</span>.m_nTwo = <span class="number">2</span><span class="comment">;</span>
    ShowFunTest(<span class="keyword">Test</span>)<span class="comment">;</span>
    getchar()<span class="comment">;</span>
}
</code></pre>]]>
    
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第二十篇：类和对象 之 “this指针”]]></title>
    <link href="http://0x520.com/2015/04/20/reverse/20/"/>
    <id>http://0x520.com/2015/04/20/reverse/20/</id>
    <published>2015-04-19T16:00:00.000Z</published>
    <updated>2015-05-23T03:41:17.000Z</updated>
    <content type="html"><![CDATA[<p>写C++应该会经常用到this指针，但是我们在类中并没有找到this的定义，许多程序员只知道使用this指针，但是不知道this从何而来。今天，我们来解开this指针的神秘的面纱！</p>
<p>首先，this是一个指针，在32位环境下占4字节大小，保存的数据应为内存地址。</p>
<h2 id="1、结构体指针">1、结构体指针</h2><p>我们先分析一段结构体：</p>
<pre><code><span class="keyword">struct</span> A 
{
    <span class="keyword">int</span>        m_int;
    <span class="keyword">short</span>    m_short;
};
<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    <span class="keyword">struct</span> A a    = {<span class="number">1</span>,<span class="number">2</span>};
    <span class="keyword">struct</span> A *p = &amp;a;
    <span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;p-&gt;m_int);
    <span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;p-&gt;m_short);
    getchar();
}
</code></pre><p>下面是对结构体的反汇编的分析：</p>
<p><img src="/uploads/2014/07/823362416.png" alt="1.png"></p>
<p>通过上图可以看到，结构体指针的地址就是此<code>结构的首地址</code>。</p>
<p>那么类对象呢？我们在下一小节继续分析。</p>
<h2 id="2、this指针">2、this指针</h2><p>我们编写一个测试类：</p>
<pre><code><span class="keyword">class</span> CTest{
<span class="keyword">public</span>:
    <span class="keyword">int</span> m_int;
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> n)</span>
    </span>{
        m_int = n;
    }
};

<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest Test;
    Test.SetNumber(<span class="number">10</span>);
    <span class="built_in">printf</span>(<span class="string">"%p \r\n"</span>, &amp;Test);
    <span class="built_in">printf</span>(<span class="string">"%p \r\n"</span>, &amp;Test.m_int);
    getchar();
}
</code></pre><p>输出结果与我们预期的相同，对象地址与第一个元素的地址相同（0033FAE8），如下图：</p>
<p><img src="/uploads/2014/07/1934018967.png" alt="2.png"></p>
<p>下面我们分析反汇编代码：</p>
<p><img src="/uploads/2014/07/2638181270.png" alt="3.png"></p>
<p>通过上图的分析，可以得知：</p>
<ul>
<li>this指针的地址 = 对象的首地址 = 第一个成员变量的地址。</li>
<li>调用成员函数时，一般采用 <code>ecx保存this指针</code>，在成员函数内部会可以使用这个值。</li>
</ul>
<h2 id="3、stdcall调用方式的成员函数">3、stdcall调用方式的成员函数</h2><p>C++中调用成员函数默认使用的是thiscall，thiscall中默认使用ecx传递this指针变量。但是，在stdcall中，this的传递方式是不同的。</p>
<p>测试代码：</p>
<pre><code><span class="keyword">class</span> CTest{
<span class="keyword">public</span>:
    <span class="keyword">int</span> m_int;
<span class="keyword">public</span>:
    <span class="comment">//调用方式为stdcall</span>
    <span class="keyword">void</span> _<span class="function">stdcall <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> n)</span>
    </span>{
        m_int = n;
    }
};
<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest Test;
    Test.SetNumber(<span class="number">10</span>);
    <span class="built_in">printf</span>(<span class="string">"%p \r\n"</span>, &amp;Test);
    <span class="built_in">printf</span>(<span class="string">"%p \r\n"</span>, &amp;Test.m_int);
    getchar();
}
</code></pre><p>反汇编代码：</p>
<p><img src="/uploads/2014/07/446336290.png" alt="4.png"></p>
<p>当使用stdcall时，编译器会隐含的传递一个this指针作为第一个参数，相当于：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">(<span class="keyword">this</span>, parameter...)</span>
</span>{
    <span class="comment">//..do something..</span>
}
</code></pre><p>实际上，大多数面向对象的编程语言，都是这么传递this指针的。</p>
<p>如果有过python编程经验的人，应该注意到在调用成员函数时候，是显示的传递this指针：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span>
    <span class="comment">#定义了一个属性</span>
    name = <span class="string">'jack'</span>       
    <span class="comment">#定义了一个方法，这里显示的传递self（this）指针</span>
    <span class="function"><span class="keyword">def</span> <span class="title">printName</span><span class="params">(self)</span>:</span> 
        <span class="keyword">print</span> self.name
</code></pre><p>这里不讲python，仅供参考，对比学习。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写C++应该会经常用到this指针，但是我们在类中并没有找到this的定义，许多程序员只知道使用this指针，但是不知道this从何而来。今天，我们来解开this指针的神秘的面纱！</p>
<p>首先，this是一个指针，在32位环境下占4字节大小，保存的数据应为内存地址。]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第十九篇：内存对齐]]></title>
    <link href="http://0x520.com/2015/04/19/reverse/19/"/>
    <id>http://0x520.com/2015/04/19/reverse/19/</id>
    <published>2015-04-18T16:00:00.000Z</published>
    <updated>2015-05-23T03:41:17.000Z</updated>
    <content type="html"><![CDATA[<p>结构体和类在为数据成员分配内存时，结构体中当前数据类型长度为M，制定的对齐值为N，那么实际对齐值 Q = min(M,N) 其成员的地址安排在Q的倍数上。</p>
<p>测试代码：</p>
<pre><code><span class="keyword">struct</span> tagTest{
    <span class="keyword">short</span> nShort;
    <span class="keyword">int</span> nInt;
} test;
<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    test.nShort = <span class="number">1</span>;
    test.nInt    = <span class="number">2</span>;
    <span class="keyword">int</span> nSize = <span class="keyword">sizeof</span>(test);
    <span class="built_in">printf</span>(<span class="string">"%d"</span>,nSize);
    getchar();
}
</code></pre><p>部分反汇编结果：</p>
<pre><code>    <span class="keyword">test</span>.nShort = <span class="number">1</span><span class="comment">;</span>
00C32D1E  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="number">1</span>  
00C32D23  <span class="keyword">mov</span>         <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="keyword">test</span> (<span class="number">0C37138h</span>)],<span class="number">ax</span>      <span class="comment">;这里是short类型的赋值</span>
    <span class="keyword">test</span>.nInt    = <span class="number">2</span><span class="comment">;</span>
00C32D29  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="keyword">test</span>+<span class="number">4</span> (<span class="number">0C3713Ch</span>)],<span class="number">2</span>    <span class="comment">;这里test+4进行了对齐</span>
    <span class="keyword">int</span> nSize = sizeof(<span class="keyword">test</span>)<span class="comment">;</span>
00C32D33  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [nSize],<span class="number">8</span>                <span class="comment">;sizeof 的结果为8</span>
</code></pre><p>对nShort赋值之后，应在地址00C3713A（0C37138h+2）处分配nInt的空间。 但是int类型占4个字节，与指定的对齐（VC6中默认的对齐是8字节）比较后，但是00C3713A不是4的倍数，需要插入两个字节补充，因此nInt被定义在了0C3713Ch处。</p>
<p>内存对齐实战：</p>
<p>第一：</p>
<pre><code><span class="keyword">struct</span>{
    <span class="keyword">double</span> nDouble;     <span class="comment">//占8字节</span>
    <span class="keyword">int</span> nInt;           <span class="comment">//占4字节</span>
    <span class="keyword">short</span> nShort;       <span class="comment">//占2字节</span>
}
按默认的对齐值要求，结构体的整体大小要能被<span class="number">8</span>整除（<span class="number">8</span>=结构的第一个元素长度），所以要 <span class="number">8</span>+<span class="number">4</span>+<span class="number">4</span>+<span class="number">2</span>+<span class="number">2</span>=<span class="number">16</span>
</code></pre><p>第二：</p>
<pre><code><span class="keyword">struct</span>{
    <span class="keyword">char</span> nChar;        <span class="comment">//占4字节，与nInt对齐</span>
    <span class="keyword">int</span> nInt;          <span class="comment">//占4字节</span>
    <span class="keyword">short</span> nShort;       <span class="comment">//占2字节</span>
}
</code></pre><p>第三：</p>
<pre><code><span class="preprocessor">#<span class="keyword">pragma</span> pack(1)        <span class="comment">//声明1字节对齐</span></span>
<span class="keyword">struct</span>{
    <span class="keyword">char</span> nChar;        <span class="comment">//占1字节</span>
    <span class="keyword">int</span> nInt;          <span class="comment">//占4字节</span>
    <span class="keyword">short</span> nShort;       <span class="comment">//占2字节</span>
}
</code></pre><p>第四：</p>
<pre><code><span class="keyword">struct</span>{
    <span class="keyword">char</span> nChar;        <span class="comment">//占1字节</span>
    <span class="keyword">char</span> cArray[<span class="number">4</span>];    <span class="comment">//占5字节，对齐nShort</span>
    <span class="keyword">short</span> nShort;       <span class="comment">//占2字节</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>结构体和类在为数据成员分配内存时，结构体中当前数据类型长度为M，制定的对齐值为N，那么实际对齐值 Q = min(M,N) 其成员的地址安排在Q的倍数上。</p>
<p>测试代码：</p>
<pre><code><span class="keyword">struct</s]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS 10.10 -Android studio was unable to find a valid JVM解决办法]]></title>
    <link href="http://0x520.com/2015/04/01/issue/1/"/>
    <id>http://0x520.com/2015/04/01/issue/1/</id>
    <published>2015-03-31T16:00:00.000Z</published>
    <updated>2015-05-23T03:35:49.000Z</updated>
    <content type="html"><![CDATA[<p>Mac OS Yosemite 10.10 下安装 Android Studio 报错：Android studio was unable to find a valid JVM</p>
<p>OsX 10.10 默认安装的是java8，但是Android Studio默认使用的是java6，解决方案如下：</p>
<h2 id="方法1：修改android_Studio_配置文件">方法1：修改android Studio 配置文件</h2><p>编辑 <code>/Applications/Android Studio.app/Contents/Info.plist</code> 文件，修改：</p>
<pre><code><span class="variable">&lt;key&gt;</span>JVMVersion<span class="variable">&lt;/key&gt;</span>
<span class="variable">&lt;string&gt;</span>1.8<span class="keyword">*</span><span class="variable">&lt;/string&gt;</span>
</code></pre><p>默认值为1.6，改为1.8即可</p>
<h2 id="方法2：修改java版本">方法2：修改java版本</h2><p>编辑 ~/.bash_profile 文件，指定java版本：</p>
<pre><code>export JAV<span class="built_in">A_HOME</span>=<span class="escape">`/</span>usr/libexec/jav<span class="built_in">a_home</span> -v <span class="number">1.7</span><span class="escape">`
</span>或者
export JAV<span class="built_in">A_HOME</span>=<span class="escape">`/</span>usr/libexec/jav<span class="built_in">a_home</span> -v <span class="number">1.8</span>`
</code></pre><h2 id="解决Android_Studio初次加载慢的问题：">解决Android Studio初次加载慢的问题：</h2><p>编辑：/Applications/Android Studio.app/Contents/bin/idea.properties<br>在文件最后增加：<code>disable.android.first.run=true</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mac OS Yosemite 10.10 下安装 Android Studio 报错：Android studio was unable to find a valid JVM</p>
<p>OsX 10.10 默认安装的是java8，但是Android Studio默认]]>
    </summary>
    
      <category term="Android" scheme="http://0x520.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu12.04下使用pptpd搭建vpn服务器]]></title>
    <link href="http://0x520.com/2015/01/04/operation/4/"/>
    <id>http://0x520.com/2015/01/04/operation/4/</id>
    <published>2015-01-03T16:00:00.000Z</published>
    <updated>2015-05-23T03:33:03.000Z</updated>
    <content type="html"><![CDATA[<p>购买了一台阿里云香港节点，准备搭建一台vpn服务器，步骤如下：</p>
<h3 id="1-_系统升级">1. 系统升级</h3><pre><code>sudo apt-<span class="built_in">get</span> <span class="keyword">update</span>
sudo apt-<span class="built_in">get</span> upgrade
</code></pre><h3 id="2-_安装pptpd">2. 安装pptpd</h3><pre><code>sudo apt-<span class="keyword">get</span> install pptpd
</code></pre><h3 id="3-_配置网络">3. 配置网络</h3><pre><code><span class="title">vim</span> /etc/pptpd.conf 

改为：

localip <span class="number">58.96.189.115</span>            <span class="comment">#网卡地址</span>
remoteip <span class="number">192.168.0.100</span>-<span class="number">200</span>       <span class="comment">#分配的IP地址范围</span>
</code></pre><h3 id="4-_添加用户">4. 添加用户</h3><pre><code>vim /etc/ppp/chap-secrets

<span class="preprocessor">#以Tab键分割，添加用户</span>

<span class="preprocessor"># client    server    secret            IP addresses</span>
test    *    test    *

<span class="preprocessor">#用户名：test，密码：test，* 代表允许任何来源</span>
</code></pre><h3 id="5-_修改DNS">5. 修改DNS</h3><pre><code><span class="title">vim</span> /etc/ppp/pptpd-options 

改为：

ms-dns <span class="number">8.8.8.8</span>  
ms-dns <span class="number">8.8.4.4</span>  
</code></pre><h3 id="6-_IP转发">6. IP转发</h3><pre><code>vim /etc/sysctl<span class="class">.conf</span>  

开启
net<span class="class">.ipv4</span><span class="class">.ip_forward</span>=<span class="number">1</span>  

执行命令，开启转发规则：
sudo sysctl -<span class="tag">p</span>  
sudo iptables -t nat -I POSTROUTING -j MASQUERADE  
</code></pre><h3 id="7-_重启">7. 重启</h3><pre><code>sudo <span class="keyword">service</span> pptpd <span class="literal">restart</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>购买了一台阿里云香港节点，准备搭建一台vpn服务器，步骤如下：</p>
<h3 id="1-_系统升级">1. 系统升级</h3><pre><code>sudo apt-<span class="built_in">get</span> <span class="keywo]]>
    </summary>
    
      <category term="linux" scheme="http://0x520.com/tags/linux/"/>
    
      <category term="pptpd" scheme="http://0x520.com/tags/pptpd/"/>
    
      <category term="shell" scheme="http://0x520.com/tags/shell/"/>
    
      <category term="vpn" scheme="http://0x520.com/tags/vpn/"/>
    
      <category term="翻墙" scheme="http://0x520.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="运维" scheme="http://0x520.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://0x520.com/categories/Linux/"/>
    
      <category term="运维" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu 12.04 下搭建DHCP服务器]]></title>
    <link href="http://0x520.com/2015/01/03/operation/3/"/>
    <id>http://0x520.com/2015/01/03/operation/3/</id>
    <published>2015-01-02T16:00:00.000Z</published>
    <updated>2015-05-23T03:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>参考链接：<br><a href="https://help.ubuntu.com/community/isc-dhcp-server" target="_blank" rel="external">https://help.ubuntu.com/community/isc-dhcp-server</a></p>
<p>当前路由器IP: 192.168.7.1，并关闭DHCP服务。<br>配置Linux服务器IP地址为固定IP地址，编辑 /etc/network/interfaces </p>
<pre><code><span class="tag">auto</span> <span class="tag">lo</span>
<span class="tag">iface</span> <span class="tag">lo</span> <span class="tag">inet</span> <span class="tag">loopback</span>

<span class="tag">auto</span> <span class="tag">eth0</span>
<span class="tag">iface</span> <span class="tag">eth0</span> <span class="tag">inet</span> <span class="tag">static</span>
<span class="tag">address</span> 192<span class="class">.168</span><span class="class">.7</span><span class="class">.2</span>
<span class="tag">gateway</span> 192<span class="class">.168</span><span class="class">.7</span><span class="class">.1</span>
<span class="tag">netmask</span> 255<span class="class">.255</span><span class="class">.255</span><span class="class">.0</span> 
</code></pre><p>重启网卡：</p>
<pre><code>sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/networking restart</span>
</code></pre><p>首先安装DHCP服务器：</p>
<pre><code>sudo apt-get <span class="operator"><span class="keyword">install</span> isc-dhcp-<span class="keyword">server</span></span>
</code></pre><p>备份dhcp的当前配置文件：</p>
<pre><code>sudo cp /etc/dhcp/dhcpd<span class="class">.conf</span> /etc/dhcp3/dhcpd<span class="class">.conf</span><span class="class">.bak</span>
</code></pre><p>修改配置文件如下：</p>
<pre><code>default-lease-time 600<span class="comment">;</span>
max-lease-time 7200<span class="comment">;</span>
option subnet-mask <span class="number">255.255.255.0</span><span class="comment">;</span>
option broadcast-address <span class="number">192.168.7.255</span><span class="comment">;</span>
option routers <span class="number">192.168.7.1</span><span class="comment">;</span>
option domain-name-servers <span class="number">192.168.7.1</span>, <span class="number">192.168.7.2</span><span class="comment">;</span>
option domain-name "mydomain.example"<span class="comment">;</span>
subnet <span class="number">192.168.7.0</span> netmask <span class="number">255.255.255.0</span> {
    range <span class="number">192.168.7.3</span> <span class="number">192.168.7.253</span><span class="comment">;</span>
} 
</code></pre><p>启动或关闭DHCP服务：</p>
<pre><code>sudo <span class="keyword">service</span> isc-dhcp-server <span class="literal">restart</span>
sudo <span class="keyword">service</span> isc-dhcp-server <span class="literal">start</span>
sudo <span class="keyword">service</span> isc-dhcp-server <span class="literal">stop</span> 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>参考链接：<br><a href="https://help.ubuntu.com/community/isc-dhcp-server" target="_blank" rel="external">https://help.ubuntu.com/community/isc]]>
    </summary>
    
      <category term="linux" scheme="http://0x520.com/tags/linux/"/>
    
      <category term="shell" scheme="http://0x520.com/tags/shell/"/>
    
      <category term="运维" scheme="http://0x520.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://0x520.com/categories/Linux/"/>
    
      <category term="运维" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu12.04 下搭建 nginx + php + mysql 环境]]></title>
    <link href="http://0x520.com/2015/01/02/operation/1/"/>
    <id>http://0x520.com/2015/01/02/operation/1/</id>
    <published>2015-01-01T16:00:00.000Z</published>
    <updated>2015-05-23T03:28:55.000Z</updated>
    <content type="html"><![CDATA[<p>1、安装mysql</p>
<pre><code>sudo apt-get install mysql-<span class="keyword">server</span> mysql-<span class="keyword">client</span>
</code></pre><p>2、安装nginx</p>
<pre><code>sudo apt-<span class="keyword">get</span> install nginx
</code></pre><p>或者你可以安装最新版本到nginx：</p>
<pre><code>sudo apt-get install python-software-properties
sudo<span class="instruction"> add-apt-repository </span>ppa:nginx/stable
sudo apt-get update
sudo apt-get install nginx
</code></pre><p>安装完毕，重启：</p>
<pre><code>sudo <span class="keyword">service</span> nginx <span class="literal">start</span>
</code></pre><p>你可以访问 <a href="http://27.0.0.1" target="_blank" rel="external">http://27.0.0.1</a> 来检查一下是否安装成功。</p>
<p>3、安装php5-fpm</p>
<pre><code>sudo apt-<span class="keyword">get</span> install php5-fpm
</code></pre><p>4、配置nginx</p>
<pre><code>sudo vi <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span><span class="keyword">default</span>
</code></pre><p>内容如下：</p>
<pre><code><span class="title">server</span> {
    <span class="title">listen</span> <span class="number">8081</span> default_server;
    <span class="title">server_name</span>     localhost;

    <span class="title">root</span>        /var/www;
    <span class="title">index</span>         index.php index.html index.htm;

    <span class="title">location</span> <span class="regexp">~ \.php$</span> {
        <span class="title">fastcgi_pass</span> <span class="url">unix:/var/run/php5-fpm.sock</span>;
        <span class="title">fastcgi_index</span> index.php;
        <span class="title">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;
        <span class="title">include</span> fastcgi_params;
    }
}
</code></pre><p>5、配置php-fpm</p>
<pre><code>sudo vi <span class="regexp">/etc/</span>php5<span class="regexp">/fpm/</span>pool.d<span class="regexp">/www.conf</span>
</code></pre><p>里面找到这样一段代码：</p>
<pre><code><span class="title">listen</span> = <span class="number">127.0.0.1:9000</span> 
</code></pre><p>在这上面代码的下面添加一行：</p>
<pre><code>listen = /<span class="keyword">var</span>/<span class="keyword">run</span>/php5-fpm.sock
</code></pre><p>6、检查nginx+php是否工作</p>
<pre><code>sudo vi /<span class="keyword">var</span>/www/info.php
</code></pre><p>添加以下内容：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span> phpinfo();<span class="preprocessor">?&gt;</span></span>
</code></pre><p>重启服务：</p>
<pre><code>sudo <span class="keyword">service</span> nginx <span class="literal">restart</span>
sudo <span class="keyword">service</span> php5-fpm <span class="literal">restart</span>
</code></pre><p>访问：<a href="http://localhost:8081/info.php" target="_blank" rel="external">http://localhost:8081/info.php</a></p>
<p>==================================</p>
<p>在安装过程中遇到两个问题，</p>
<p>第一个问题：访问<a href="http://localhost:8081/info.php" target="_blank" rel="external">http://localhost:8081/info.php</a> 返回502错误，查看 /var/log/nginx/error.log 发现有以下错误：</p>
<pre><code><span class="number">2014</span>/<span class="number">10</span>/<span class="number">22</span> <span class="number">11</span>:<span class="number">13</span>:<span class="number">26</span> [<span class="id">crit</span>] <span class="number">4936#0</span>: *<span class="number">3</span> <span class="id">connect</span>() <span class="id">to</span> <span class="id">unix</span>:/<span class="id">var</span>/<span class="id">run</span>/<span class="id">php5</span>-<span class="id">fpm</span>.<span class="id">sock</span> <span class="id">failed</span> (<span class="number">13</span>: <span class="variable">Permission</span> <span class="id">denied</span>) <span class="id">while</span> <span class="id">connecting</span> <span class="id">to</span> <span class="id">upstream</span>, <span class="id">client</span>: <span class="number">127.0</span>.<span class="number">0.1</span>, <span class="id">server</span>: <span class="id">localhost</span>, <span class="id">request</span>: <span class="string">"GET /index.php HTTP/1.1"</span>, <span class="id">upstream</span>: <span class="string">"fastcgi://unix:/var/run/php5-fpm.sock:"</span>, <span class="id">host</span>: <span class="string">"localhost:8081"</span>
</code></pre><p>解决办法，修改/var/run/php5-fpm.sock权限：</p>
<pre><code>chmod 777 /<span class="keyword">var</span>/<span class="keyword">run</span>/php5-fpm.sock
</code></pre><p>第二个问题：访问<a href="http://localhost:8081/info.php" target="_blank" rel="external">http://localhost:8081/info.php</a> 没有任何输出，浏览器看到的是空白页面。查看/var/log/nginx/access.log访问日志，显示是200，是正确的结果。</p>
<p>解决办法：<br>在nginx配置文件default中，增加：</p>
<pre><code><span class="title">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;
</code></pre><p>上文中已经给出来正确的配置方式。</p>
<p>参考链接：</p>
<p><a href="http://ubuntuhandbook.org/index.php/2013/10/install-nginx-php5-mysql-lemp-ubuntu-1310/" target="_blank" rel="external">http://ubuntuhandbook.org/index.php/2013/10/install-nginx-php5-mysql-lemp-ubuntu-1310/</a></p>
<p><a href="http://www.3lian.com/edu/2012/12-10/48565.html" target="_blank" rel="external">http://www.3lian.com/edu/2012/12-10/48565.html</a></p>
<p><a href="http://blog.csdn.net/liangpz521/article/details/8869470" target="_blank" rel="external">http://blog.csdn.net/liangpz521/article/details/8869470</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、安装mysql</p>
<pre><code>sudo apt-get install mysql-<span class="keyword">server</span> mysql-<span class="keyword">client</span>
</code>]]>
    </summary>
    
      <category term="linux" scheme="http://0x520.com/tags/linux/"/>
    
      <category term="nginx" scheme="http://0x520.com/tags/nginx/"/>
    
      <category term="php" scheme="http://0x520.com/tags/php/"/>
    
      <category term="shell" scheme="http://0x520.com/tags/shell/"/>
    
      <category term="运维" scheme="http://0x520.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://0x520.com/categories/Linux/"/>
    
      <category term="运维" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="PHP" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB 集群搭建（实验）]]></title>
    <link href="http://0x520.com/2015/01/01/mongodb/1/"/>
    <id>http://0x520.com/2015/01/01/mongodb/1/</id>
    <published>2014-12-31T16:00:00.000Z</published>
    <updated>2015-05-23T04:05:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MongoDB_集群环境搭建（实验）">MongoDB 集群环境搭建（实验）</h1><h3 id="1、配置文件">1、配置文件</h3><p>mongodb-linux-x86_64-2.6.5<br>ubuntu-12.04.5-server-amd64</p>
<p>首先在VirtualBox中创建三个虚拟机，我设置的IP地址分别为：</p>
<pre><code>192<span class="class">.168</span><span class="class">.5</span><span class="class">.30</span>,<span class="tag">master</span>
192<span class="class">.168</span><span class="class">.5</span><span class="class">.31</span>,<span class="tag">slaver</span>
192<span class="class">.168</span><span class="class">.5</span><span class="class">.32</span>,<span class="tag">arbiter</span>
</code></pre><p><img src="/uploads/2014/12/3561415352.png" alt="QQ20141211-2.png"></p>
<p>在30、31、32的home目录分别创建mongo.conf文件内容如下：</p>
<p>主节点</p>
<pre><code>#master.conf    
<span class="string">systemLog:</span>
<span class="label">   destination:</span> file
<span class="label">   path:</span> <span class="string">"/var/log/mongodb/mongodb.log"</span>
<span class="label">   logAppend:</span> <span class="literal">true</span>
<span class="string">storage:</span>
<span class="label">   journal:</span>
<span class="label">      enabled:</span> <span class="literal">true</span>
<span class="string">processManagement:</span>
<span class="label">   fork:</span> <span class="literal">true</span>
<span class="string">net:</span>
<span class="label">   bindIp:</span> <span class="number">192.168</span>.5.30
<span class="label">   port:</span> <span class="number">27017</span>
<span class="string">replication:</span>
<span class="label">   replSetName:</span> <span class="string">"rs0"</span>
</code></pre><p>备节点</p>
<pre><code>#slaver.conf
<span class="string">systemLog:</span>
<span class="label">   destination:</span> file
<span class="label">   path:</span> <span class="string">"/var/log/mongodb/mongodb.log"</span>
<span class="label">   logAppend:</span> <span class="literal">true</span>
<span class="string">storage:</span>
<span class="label">   journal:</span>
<span class="label">      enabled:</span> <span class="literal">true</span>
<span class="string">processManagement:</span>
<span class="label">   fork:</span> <span class="literal">true</span>
<span class="string">net:</span>
<span class="label">   bindIp:</span> <span class="number">192.168</span>.5.31
<span class="label">   port:</span> <span class="number">27017</span>
<span class="string">replication:</span>
<span class="label">   replSetName:</span> <span class="string">"rs0"</span>
</code></pre><p>仲裁节点   </p>
<pre><code>#arbiter.conf
<span class="string">systemLog:</span>
<span class="label">   destination:</span> file
<span class="label">   path:</span> <span class="string">"/var/log/mongodb/mongodb.log"</span>
<span class="label">   logAppend:</span> <span class="literal">true</span>
<span class="string">storage:</span>
<span class="label">   journal:</span>
<span class="label">      enabled:</span> <span class="literal">true</span>
<span class="string">processManagement:</span>
<span class="label">   fork:</span> <span class="literal">true</span>
<span class="string">net:</span>
<span class="label">   bindIp:</span> <span class="number">192.168</span>.5.32
<span class="label">   port:</span> <span class="number">27017</span>
<span class="string">replication:</span>
<span class="label">   replSetName:</span> <span class="string">"rs0"</span>
</code></pre><blockquote>
<p>主意，如果/var/log/mongodb/mongodb.log没有写权限会报错</p>
</blockquote>
<h3 id="2、启用集群">2、启用集群</h3><p>1、分别登录到30、31、32服务器，启动mongod服务：</p>
<pre><code>mongod --config ~/mongo<span class="class">.conf</span> 
</code></pre><p>2、配置集群，连接到主节点</p>
<pre><code><span class="tag">mongo</span> 192<span class="class">.168</span><span class="class">.5</span><span class="class">.30</span><span class="pseudo">:27017</span>
</code></pre><p>3、初始化集群配置</p>
<pre><code>rs.initiate({<span class="string">_id:</span><span class="string">"rs0"</span>, <span class="string">members:</span>[ {<span class="string">_id:</span><span class="number">0</span>,<span class="string">host:</span><span class="string">'192.168.5.30:27017'</span>,<span class="string">priority:</span><span class="number">2</span>}, {<span class="string">_id:</span><span class="number">1</span>,<span class="string">host:</span><span class="string">'192.168.5.31:27017'</span>,<span class="string">priority:</span><span class="number">1</span>},{<span class="string">_id:</span><span class="number">2</span>,<span class="string">host:</span><span class="string">'192.168.5.32:27017'</span>,<span class="string">arbiterOnly:</span><span class="literal">true</span>}]});
</code></pre><p>输出以下内容则表示配置成功。</p>
<pre><code>{
     "<span class="attribute">info</span>" : <span class="value"><span class="string">"Config now saved locally.  Should come online in about a minute."</span></span>,
    "<span class="attribute">ok</span>" : <span class="value"><span class="number">1</span>
</span>} 
</code></pre><p>4、查看集群状态：</p>
<pre><code><span class="string">mini:</span>john$ mongo <span class="number">192.168</span>.5.30:<span class="number">27017</span>
MongoDB shell <span class="string">version:</span> <span class="number">2.6</span>.5
connecting <span class="string">to:</span> <span class="number">192.168</span>.5.30:<span class="number">27017</span>/test
<span class="string">rs0:</span>PRIMARY&gt; rs.conf()
{
    <span class="string">"_id"</span> : <span class="string">"rs0"</span>,
    <span class="string">"version"</span> : <span class="number">1</span>,
    <span class="string">"members"</span> : [
        {
            <span class="string">"_id"</span> : <span class="number">0</span>,
            <span class="string">"host"</span> : <span class="string">"192.168.5.30:27017"</span>,
            <span class="string">"priority"</span> : <span class="number">2</span>
        },
        {
            <span class="string">"_id"</span> : <span class="number">1</span>,
            <span class="string">"host"</span> : <span class="string">"192.168.5.31:27017"</span>
        },
        {
            <span class="string">"_id"</span> : <span class="number">2</span>,
            <span class="string">"host"</span> : <span class="string">"192.168.5.32:27017"</span>,
            <span class="string">"arbiterOnly"</span> : <span class="literal">true</span>
        }
    ]
}
</code></pre><p>主意：SECONDARY是不允许读写的，现在的从库只是用来备份主库的数据。如果在从库中执行读写操作，会产生以下错误。</p>
<pre><code><span class="tag">SECONDARY</span>&gt; <span class="tag">db</span><span class="class">.user</span><span class="class">.find</span>()
<span class="rule"><span class="attribute">error</span>:<span class="value"> { <span class="string">"$err"</span> : <span class="string">"not master and slaveok=false"</span>, <span class="string">"code"</span> : <span class="number">13435</span> }</span></span>
</code></pre><p>如果要用SECONDARY来分担读压力，可参考这篇文章：<a href="http://blog.163.com/lgh_2002/blog/static/44017526201301123736391/" target="_blank" rel="external">http://blog.163.com/lgh_2002/blog/static/44017526201301123736391/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MongoDB_集群环境搭建（实验）">MongoDB 集群环境搭建（实验）</h1><h3 id="1、配置文件">1、配置文件</h3><p>mongodb-linux-x86_64-2.6.5<br>ubuntu-12.04.5-server-amd64</]]>
    </summary>
    
      <category term="mongodb" scheme="http://0x520.com/tags/mongodb/"/>
    
      <category term="MongoDB" scheme="http://0x520.com/categories/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu 12.04 下配置 uwsgi + nginx + web.py 环境]]></title>
    <link href="http://0x520.com/2015/01/01/operation/2/"/>
    <id>http://0x520.com/2015/01/01/operation/2/</id>
    <published>2014-12-31T16:00:00.000Z</published>
    <updated>2015-05-23T03:27:47.000Z</updated>
    <content type="html"><![CDATA[<p>1、准备</p>
<pre><code>apt-<span class="built_in">get</span> <span class="keyword">update</span>
apt-<span class="built_in">get</span> upgrade
</code></pre><p>2、安装nginx、uwsgi</p>
<pre><code>apt-get <span class="operator"><span class="keyword">install</span> nginx-<span class="keyword">full</span> uwsgi uwsgi-<span class="keyword">plugin</span>-python</span>
</code></pre><p>3、创建文件/etc/nginx/sites-available/example.com</p>
<pre><code><span class="xml">server </span><span class="expression">{
        <span class="variable">listen</span> 80;
    <span class="variable">server</span>_<span class="variable">name</span>     <span class="variable">localhost</span>;

    <span class="variable">access</span>_<span class="variable">log</span>    <span class="end-block">/var</span><span class="end-block">/www</span><span class="end-block">/example.com</span><span class="end-block">/logs</span><span class="end-block">/access.log</span>;
    <span class="variable">error</span>_<span class="variable">log</span>    <span class="end-block">/var</span><span class="end-block">/www</span><span class="end-block">/example.com</span><span class="end-block">/logs</span><span class="end-block">/error.log</span>;

        <span class="variable">location</span> <span class="end-block">/ </span>{
        <span class="variable">include</span>     <span class="variable">uwsgi</span>_<span class="variable">params</span>;
                <span class="variable">uwsgi</span>_<span class="variable">pass</span>      127<span class="variable">.</span>0<span class="variable">.</span>0<span class="variable">.</span>1:9001;
        }</span><span class="xml">

        location /static </span><span class="expression">{
                <span class="variable">root</span> <span class="end-block">/var</span><span class="end-block">/www</span><span class="end-block">/example.com</span><span class="end-block">/public</span>_<span class="variable">html</span><span class="end-block">/static</span>/;
                <span class="variable">index</span> <span class="variable">index.html</span>;
        }</span><span class="xml">
}</span>
</code></pre><p>4、新建软链接</p>
<pre><code>ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>example.com <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>example.com
</code></pre><p>5、创建文件 /etc/uwsgi/apps-available/example.com.xml </p>
<pre><code><span class="tag">&lt;<span class="title">uwsgi</span>&gt;</span>
    <span class="tag">&lt;<span class="title">plugins</span>&gt;</span>python<span class="tag">&lt;/<span class="title">plugins</span>&gt;</span>
    <span class="tag">&lt;<span class="title">socket</span>&gt;</span>127.0.0.1:9001<span class="tag">&lt;/<span class="title">socket</span>&gt;</span>  
    <span class="tag">&lt;<span class="title">module</span>&gt;</span>myapp<span class="tag">&lt;/<span class="title">module</span>&gt;</span>  
    <span class="comment">&lt;!-- &lt;master /&gt;  --&gt;</span>
    <span class="tag">&lt;<span class="title">pythonpath</span>&gt;</span>/var/www/example.com/application<span class="tag">&lt;/<span class="title">pythonpath</span>&gt;</span>  
    <span class="comment">&lt;!-- &lt;chdir&gt;/var/www/example.com/application&lt;/chdir&gt;   --&gt;</span>    
    <span class="tag">&lt;<span class="title">processes</span>&gt;</span>2<span class="tag">&lt;/<span class="title">processes</span>&gt;</span>  
    <span class="tag">&lt;<span class="title">workers</span>&gt;</span>4<span class="tag">&lt;/<span class="title">workers</span>&gt;</span>
    <span class="tag">&lt;<span class="title">max-requests</span>&gt;</span>10000<span class="tag">&lt;/<span class="title">max-requests</span>&gt;</span>  
    <span class="comment">&lt;!--
    &lt;memory-report/&gt;  
    &lt;pidfile&gt;/tmp/uwsgi_myapp.pid&lt;/pidfile&gt;  
    &lt;max-requests&gt;10000&lt;/max-requests&gt;  
    &lt;daemonize&gt;/var/log/uwsgi_myapp.log&lt;/daemonize&gt;   
    --&gt;</span>
<span class="tag">&lt;/<span class="title">uwsgi</span>&gt;</span>  
</code></pre><p>6、新建软链接</p>
<pre><code>ln -s /etc/uwsgi/apps-available/example<span class="class">.com</span><span class="class">.xml</span> /etc/uwsgi/apps-enabled/example<span class="class">.com</span><span class="class">.xml</span>
</code></pre><p>7、创建应用目录</p>
<pre><code>mkdir -p <span class="regexp">/var/</span>www<span class="regexp">/example.com/</span>public_html/<span class="keyword">static</span>
mkdir <span class="regexp">/var/</span>www<span class="regexp">/example.com/</span>application
mkdir <span class="regexp">/var/</span>www<span class="regexp">/example.com/</span>logs
</code></pre><p>8、在/var/www/example.com/application目录下新建 <code>myapp.py</code> 文件</p>
<pre><code><span class="keyword">import</span> web

urls = (<span class="string">'/'</span>,<span class="string">'hello'</span>)

<span class="class"><span class="keyword">class</span> <span class="title">hello</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> <span class="string">"hello world"</span>

app = web.application(urls,globals())

application = app.wsgifunc()

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    app.run()
</code></pre><p>注意：文件名与example.com.xml中的<module>节点的内容相同。</module></p>
<p>9、重启</p>
<pre><code><span class="keyword">service</span> nginx <span class="literal">restart</span>
<span class="keyword">service</span> nwsgi <span class="literal">restart</span>
</code></pre><p>10、访问 <a href="http://localhost/，进行验证" target="_blank" rel="external">http://localhost/，进行验证</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、准备</p>
<pre><code>apt-<span class="built_in">get</span> <span class="keyword">update</span>
apt-<span class="built_in">get</span> upgra]]>
    </summary>
    
      <category term="linux" scheme="http://0x520.com/tags/linux/"/>
    
      <category term="nginx" scheme="http://0x520.com/tags/nginx/"/>
    
      <category term="python" scheme="http://0x520.com/tags/python/"/>
    
      <category term="shell" scheme="http://0x520.com/tags/shell/"/>
    
      <category term="运维" scheme="http://0x520.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://0x520.com/categories/Linux/"/>
    
      <category term="运维" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Python" scheme="http://0x520.com/categories/Linux/%E8%BF%90%E7%BB%B4/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第二十二篇：构造函数]]></title>
    <link href="http://0x520.com/2014/05/22/reverse/22/"/>
    <id>http://0x520.com/2014/05/22/reverse/22/</id>
    <published>2014-05-21T16:00:00.000Z</published>
    <updated>2015-05-23T03:41:19.000Z</updated>
    <content type="html"><![CDATA[<p>对象生成时会自动调用构造函数，然而不同作用域的对象生命周期不同，局部对象、全局对象、静态对象等，当对象的生命周期不同时，构造函数的调用时机就会不同。</p>
<h3 id="1-1、局部对象">1.1、局部对象</h3><pre><code>class CTest{
<span class="label">public:</span>
    CTest(){
        m_nNumber = <span class="number">1</span><span class="comment">;</span>
    }
    <span class="keyword">int</span> m_nNumber<span class="comment">;</span>
}<span class="comment">;</span>
<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest <span class="keyword">test</span><span class="comment">;</span>
}

===============================_tmain===============================

    CTest <span class="keyword">test</span><span class="comment">;</span>
00FB13AE  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="keyword">test</span>]              <span class="comment">;取得对象的首地址</span>
00FB13B1  <span class="keyword">call</span>        CTest::CTest (<span class="number">0FB11C7h</span>) <span class="comment">;调用构造函数</span>

===============================构造函数===============================

00FB1460  <span class="keyword">push</span>        <span class="literal">ebp</span>  
00FB1461  <span class="keyword">mov</span>         <span class="literal">ebp</span>,<span class="literal">esp</span>  
00FB1463  <span class="keyword">sub</span>         <span class="literal">esp</span>,<span class="number">0CCh</span>  
00FB1469  <span class="keyword">push</span>        <span class="number">ebx</span>  
00FB146A  <span class="keyword">push</span>        <span class="literal">esi</span>  
00FB146B  <span class="keyword">push</span>        <span class="literal">edi</span>  
00FB146C  <span class="keyword">push</span>        <span class="number">ecx</span>  
00FB146D  <span class="keyword">lea</span>         <span class="literal">edi</span>,[<span class="literal">ebp</span>-<span class="number">0CCh</span>]  
00FB1473  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="number">33h</span>  
00FB1478  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="number">0CCCCCCCCh</span>  
00FB147D  <span class="keyword">rep</span> stos    <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">es</span>:[<span class="literal">edi</span>]  
00FB147F  <span class="keyword">pop</span>         <span class="number">ecx</span>  
00FB1480  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">8</span>],<span class="number">ecx</span>  
00FB1483  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [this]      <span class="comment">;对象首地址</span>
00FB1486  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>],<span class="number">1</span>         <span class="comment">;给m_nNumber赋值</span>
00FB148C  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [this]      <span class="comment">;对象首地址赋值给eax，exa作为函数的返回值</span>
00FB148F  <span class="keyword">pop</span>         <span class="literal">edi</span>  
00FB1490  <span class="keyword">pop</span>         <span class="literal">esi</span>  
00FB1491  <span class="keyword">pop</span>         <span class="number">ebx</span>  
00FB1492  <span class="keyword">mov</span>         <span class="literal">esp</span>,<span class="literal">ebp</span>  
00FB1494  <span class="keyword">pop</span>         <span class="literal">ebp</span>  
00FB1495  <span class="keyword">ret</span>  
</code></pre><p>构造函数属于成员函数，在调用时会传递this指针，在构造函数结束后，会将this指针作为函数返回值。</p>
<h3 id="1-2、堆对象">1.2、堆对象</h3><p>堆对象的识别，在于识别堆空间的申请，在C++中申请堆空间需要使用malloc或new运算符。</p>
<pre><code><span class="keyword">class</span> <span class="type">CTest</span>{
public:
    <span class="type">CTest</span><span class="literal">()</span>{
        m_nNumber = <span class="number">1</span>;
    }
    <span class="built_in">int</span> m_nNumber;
};
<span class="built_in">int</span> _tmain(<span class="built_in">int</span> argc, _TCHAR* argv<span class="literal">[]</span>)
{
    <span class="type">CTest</span>* pTest        = <span class="type">NULL</span>;
    pTest                = <span class="keyword">new</span> <span class="type">CTest</span>;
    pTest-&gt;m_nNumber        = <span class="number">2</span>;
    printf(<span class="string">"%d"</span>,pTest-&gt;m_nNumber);
}
</code></pre><p>反汇编代码：</p>
<pre><code>    CTest* <span class="keyword">pTest</span> = NULL<span class="comment">;</span>
010213<span class="pseudo">DD</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>],<span class="number">0</span>      <span class="comment">;指针在ebp-14h处，初始化为0</span>
    <span class="keyword">pTest</span> = new CTest<span class="comment">;</span>
010213E4  <span class="keyword">push</span>        <span class="number">4</span>                          <span class="comment">;压入类的大小，申请堆内存（申请4字节的堆内存）</span>
010213E6  <span class="keyword">call</span>        operator new (<span class="number">1021181h</span>)  
010213EB  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">4</span>  
010213EE  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0E0h</span>],<span class="number">eax</span>   <span class="comment">;临时变量保存new的返回值</span>
010213F4  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0</span>        <span class="comment">;[ebp-4]保存申请堆空间的次数</span>
010213FB  <span class="keyword">cmp</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0E0h</span>],<span class="number">0</span>     <span class="comment">;检测堆内存是否申请成功</span>
<span class="number">01021402</span>  <span class="keyword">je</span>          wmain+<span class="number">77h</span> (<span class="number">1021417h</span>)       <span class="comment">;失败：跳过构造函数，成功：执行构造函数</span>
<span class="number">01021404</span>  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0E0h</span>]   <span class="comment">;ecx保存new的返回值</span>
0102140A  <span class="keyword">call</span>        CTest::CTest (<span class="number">10211CCh</span>)    <span class="comment">;执行构造函数</span>
0102140F  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0F4h</span>],<span class="number">eax</span>   <span class="comment">;返回this指针，保存在ebp-0F4h处</span>
<span class="number">01021415</span>  <span class="keyword">jmp</span>         wmain+<span class="number">81h</span> (<span class="number">1021421h</span>)  
<span class="number">01021417</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0F4h</span>],<span class="number">0</span>     <span class="comment">;申请失败，this指针赋值为0</span>
<span class="number">01021421</span>  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0F4h</span>]   <span class="comment">;this指针赋值给eax</span>
<span class="number">01021427</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0ECh</span>],<span class="number">eax</span>   <span class="comment">;this指针赋值给ebp-0E0h</span>
<span class="number">0102142D</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0FFFFFFFFh</span>  
<span class="number">01021434</span>  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0ECh</span>]  
0102143A  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>],<span class="number">ecx</span>    <span class="comment">;this指针赋值到ebp-14h处</span>
    <span class="keyword">pTest</span>-&gt;m_nNumber = <span class="number">2</span><span class="comment">;</span>
<span class="number">0102143D</span>  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>]    <span class="comment">;获得this指针</span>
<span class="number">01021440</span>  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>],<span class="number">2</span>          <span class="comment">;给m_nNumber 赋值</span>
    printf(<span class="string">"%d"</span>,<span class="keyword">pTest</span>-&gt;m_nNumber)<span class="comment">;</span>
<span class="number">01021446</span>  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
<span class="number">01021448</span>  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>]  
0102144B  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>]  
<span class="number">0102144D</span>  <span class="keyword">push</span>        <span class="number">ecx</span>  
0102144E  <span class="keyword">push</span>        offset string <span class="string">"%d"</span> (<span class="number">1026890h</span>)  
<span class="number">01021453</span>  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">10292C4h</span>)]  
<span class="number">01021459</span>  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
0102145C  <span class="keyword">cmp</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
0102145E  <span class="keyword">call</span>        @ILT+<span class="number">310</span>(__RTC_CheckEsp) (<span class="number">102113Bh</span>)  
</code></pre><p>在使用new申请堆空间后，将申请到的堆空间首地址作为参数，然后调用构造函数。如果堆空间申请失败，则跳过构造函数。</p>
<h3 id="1-3、参数对象（拷贝构造）">1.3、参数对象（拷贝构造）</h3><p>当对象作为函数的参数时，会调用一个特殊的构造函数—拷贝构造函数。该函数只有一个参数，类型为对象的引用。</p>
<p><strong>浅拷贝</strong><br>如果在函数调用时传递参数对象，参数会进行复制，形参是实参的副本，相当于拷贝构造了一个全新的对象。如果没有定义拷贝构造函数，编译器会对原生对象与拷贝对象中的各种数据成员直接进行数据复制，成为默认拷贝构造函数，这种拷贝属于<code>浅拷贝</code>。</p>
<pre><code>class CTest{
<span class="label">public:</span>
    CTest(){
        m_nNumber = <span class="number">1</span><span class="comment">;</span>
    }
    <span class="keyword">int</span> m_nNumber<span class="comment">;</span>
}<span class="comment">;</span>
<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CTest test1<span class="comment">;</span>
    CTest test2(test1)<span class="comment">;</span>
}
======================================================
    CTest test1<span class="comment">;</span>
012413BE  <span class="keyword">lea</span>         <span class="number">ecx</span>,[test1]  
012413C1  <span class="keyword">call</span>        CTest::CTest (<span class="number">12411CCh</span>)  
    CTest test2(test1)<span class="comment">;</span>
012413C6  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [test1]          <span class="comment">;取出test1中的m_nNumber成员</span>
012413C9  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [test2],<span class="number">eax</span>          <span class="comment">;赋值给test2的m_nNumber成员</span>
</code></pre><p>当成员变量为指针类型，指向资源数据时，如果test1释放了该资源，当test2使用指向的资源时，程序就会出错。这种情况下，就需要将指向的资源也拷贝一份副本，这时就需要<code>深拷贝</code>了。</p>
<p><strong>深拷贝</strong></p>
<pre><code><span class="keyword">class</span> CMyString{
<span class="keyword">public</span>:
    CMyString(){
        <span class="comment">//初始化指针为NULL</span>
        m_pString = NULL; 
    }
    <span class="comment">//拷贝构造函数（深拷贝）</span>
    CMyString(CMyString&amp; obj)
    {
        <span class="keyword">int</span> nLen = <span class="built_in">strlen</span>(obj.m_pString);
        <span class="keyword">this</span>-&gt;m_pString = <span class="keyword">new</span> <span class="keyword">char</span>[nLen + <span class="keyword">sizeof</span>(<span class="keyword">char</span>)];
        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_pString , obj.m_pString);
    }
    ~CMyString()
    {
        <span class="keyword">if</span> (m_pString != NULL)
        {
            <span class="keyword">delete</span> [] m_pString;
            m_pString = NULL;
        }
    }
    <span class="function"><span class="keyword">void</span> <span class="title">SetString</span><span class="params">(<span class="keyword">char</span>* pString)</span>
    </span>{
        <span class="keyword">if</span> (m_pString != NULL)
        {
            <span class="keyword">delete</span> [] m_pString;
            m_pString = NULL;
        }
        <span class="keyword">int</span> nLen = <span class="built_in">strlen</span>(pString);
        m_pString = <span class="keyword">new</span> <span class="keyword">char</span>[nLen + <span class="keyword">sizeof</span>(<span class="keyword">char</span>)];
        <span class="built_in">strcpy</span>(m_pString,pString);
    }
<span class="keyword">public</span>:
    <span class="keyword">char</span>* m_pString;
};

<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(CMyString MyString)</span>
</span>{
    <span class="built_in">printf</span>(MyString.m_pString);
}

<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    CMyString MyString;
    MyString.SetString(<span class="string">"HelloWorld"</span>);
    Show(MyString);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>_tmain函数调用：</p>
<pre><code>    CMyString MyString<span class="comment">;</span>
013F151D  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>-<span class="number">14h</span>]                   <span class="comment">;取MyString对象首地址(this指针)</span>
013F1520  <span class="keyword">call</span>        CMyString::CMyString (<span class="number">13F10CDh</span>) <span class="comment">;调用无参构造函数</span>
013F1525  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">0</span>             <span class="comment">;当前作用域定义的对象个数</span>
    MyString.SetString(<span class="string">"HelloWorld"</span>)<span class="comment">;</span>
013F152C  <span class="keyword">push</span>        offset string <span class="string">"HelloWorld"</span> (<span class="number">13F6830h</span>)  
013F1531  <span class="keyword">lea</span>         <span class="number">ecx</span>,[<span class="literal">ebp</span>-<span class="number">14h</span>]                   <span class="comment">;获取this指针</span>
013F1534  <span class="keyword">call</span>        CMyString::SetString (<span class="number">13F100Ah</span>) <span class="comment">;调用成员函数</span>
    Show(MyString)<span class="comment">;</span>
013F1539  <span class="keyword">push</span>        <span class="number">ecx</span>  
013F153A  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="literal">esp</span>  
013F153C  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0ECh</span>],<span class="literal">esp</span>  
013F1542  <span class="keyword">lea</span>         <span class="number">eax</span>,[<span class="literal">ebp</span>-<span class="number">14h</span>]                   <span class="comment">;将MyString首地址作为参数</span>
013F1545  <span class="keyword">push</span>        <span class="number">eax</span>  
013F1546  <span class="keyword">call</span>        CMyString::CMyString (<span class="number">13F1104h</span>) <span class="comment">;调用拷贝构造函数</span>
013F154B  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0F4h</span>],<span class="number">eax</span>        <span class="comment">;ebp-0F4保存拷贝构造函数返回的this指针</span>
013F1551  <span class="keyword">call</span>        Show (<span class="number">13F1186h</span>)                 <span class="comment">;调用Show函数</span>
013F1556  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">4</span>  
    return <span class="number">0</span><span class="comment">;</span>
</code></pre><p>拷贝构造函数调用</p>
<pre><code>CMyString(CMyString&amp; obj)
{
    <span class="keyword">int</span> nLen = strlen(obj.m_pString)<span class="comment">;</span>
    this-&gt;m_pString = new char[nLen + sizeof(char)]<span class="comment">;</span>
    strcpy(this-&gt;m_pString , obj.m_pString)<span class="comment">;</span>
00BC1694  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [obj]             <span class="comment">;原object</span>
00BC1697  <span class="keyword">mov</span>         <span class="number">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>]  
00BC1699  <span class="keyword">push</span>        <span class="number">ecx</span>  
00BC169A  <span class="keyword">mov</span>         <span class="number">edx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [this]            <span class="comment">;新生成的object</span>
00BC169D  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="number">edx</span>]             
00BC169F  <span class="keyword">push</span>        <span class="number">eax</span>                             <span class="comment">;新生成的object首地址（this指针）</span>
00BC16A0  <span class="keyword">call</span>        @ILT+<span class="number">175</span>(_strcpy) (<span class="number">0BC10B4h</span>)  
00BC16A5  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
}
</code></pre><p>Show函数调用：</p>
<pre><code>void Show(CMyString MyString)
{
    printf(MyString.m_pString)<span class="comment">;</span>
008E140E  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
008E1410  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [MyString]  
008E1413  <span class="keyword">push</span>        <span class="number">eax</span>  
008E1414  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">8E92DCh</span>)]  
008E141A  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">4</span>  
}
008E1424  <span class="keyword">lea</span>         <span class="number">ecx</span>,[MyString]  
008E1427  <span class="keyword">call</span>        CMyString::~CMyString (<span class="number">8E1172h</span>)<span class="comment">;调用析构函数</span>
...略...
</code></pre><p>由于使用了深拷贝，对象中的数据成员指向的堆空间数据也进行了复制，因此，当函数对象被销毁时，释放的空间是拷贝对象所复制的数据副本，对原始对象没有任何影响。</p>
<h2 id="1-4、返回对象（拷贝构造）">1.4、返回对象（拷贝构造）</h2><p>—待发布—</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对象生成时会自动调用构造函数，然而不同作用域的对象生命周期不同，局部对象、全局对象、静态对象等，当对象的生命周期不同时，构造函数的调用时机就会不同。</p>
<h3 id="1-1、局部对象">1.1、局部对象</h3><pre><code>class CTest{
<sp]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第十八篇：对象的内存分布]]></title>
    <link href="http://0x520.com/2014/05/18/reverse/18/"/>
    <id>http://0x520.com/2014/05/18/reverse/18/</id>
    <published>2014-05-17T16:00:00.000Z</published>
    <updated>2015-05-23T03:27:47.000Z</updated>
    <content type="html"><![CDATA[<p>今天我们来探究一下，实例化过的对象在内存中是如何分布的。</p>
<p>下面是我写的测试代码：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">CNumber</span></span>{
<span class="keyword">public</span>:
    CNumber(){
        m_var1 = <span class="number">1</span>;
        m_var2 = <span class="number">2</span>;
    }
    <span class="function"><span class="keyword">int</span> <span class="title">GetNumber1</span><span class="params">()</span></span>{
        <span class="keyword">return</span> m_var1;
    }
    <span class="function"><span class="keyword">int</span> <span class="title">GetNumber2</span><span class="params">()</span></span>{
        <span class="keyword">return</span> m_var2;
    }
<span class="keyword">private</span>:
    <span class="keyword">int</span> m_var1;
    <span class="keyword">int</span> m_var2;
};

<span class="function"><span class="keyword">int</span> <span class="title">_tmain</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span>
</span>{
    CNumber number1;
    printf(<span class="string">"%d"</span>,number1.GetNumber1());
}
</code></pre><p><strong>反汇编结果分析</strong></p>
<p>main函数的反汇编结果如下，这里分别调用了 <code>构造函数</code> 和 <code>成员函数GetNumber1()</code>：</p>
<p><img src="/uploads/2014/07/1015622043.png" alt="2.png"></p>
<p>通过单步跟踪，得到ecx的值（对象的首地址0x0033fa48），跳转到0x0033fa48处，按顺序存放了<code>m_var1</code> 和 <code>m_var2</code> 的值，如下图：</p>
<p><img src="/uploads/2014/07/1568965340.png" alt="1.png"></p>
<p><strong>类中不能定义自身的对象，因为类在实例化过程中，需要申请内存，也就是说需要计算自身的大小。如果在类中定义了自身的对象，在计算各成员长度时，就会形成递归，而且是没有出口的递归，将会无限循环。</strong></p>
<p>总结：对象所占内存的长度 = 各数据成员大小的总和。当然，要排除掉static成员，空类、还需要考虑<a href="http://www.0x520.com/2014/07/07/303.html" target="_blank" rel="external">内存数据对齐</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们来探究一下，实例化过的对象在内存中是如何分布的。</p>
<p>下面是我写的测试代码：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title"]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第十七篇：数组和指针]]></title>
    <link href="http://0x520.com/2014/05/17/reverse/17/"/>
    <id>http://0x520.com/2014/05/17/reverse/17/</id>
    <published>2014-05-16T16:00:00.000Z</published>
    <updated>2015-05-23T03:27:47.000Z</updated>
    <content type="html"><![CDATA[<p>数组和指针都是针对地址进行操作，但是他们有很多不同之处。数组是相同类型的数据集合，是以线性的方式存储在内存中；而指针是保存4个字节的地址变量。</p>
<p>数组名是一个地址常量，保存数组第一个元素的地址（不可以更改），只能作为基址访问内存数据；<br>指针是一个变量，只要修改所保存的地址数据，就可以随意访问，不受约束。</p>
<h2 id="1、数组的定义">1、数组的定义</h2><pre><code><span class="function"><span class="keyword">int</span> <span class="title">_tmain</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span>
</span>{
    <span class="keyword">int</span> aArray[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
    <span class="keyword">int</span> var1 = <span class="number">1</span>;
    <span class="keyword">int</span> var2 = <span class="number">2</span>;
    <span class="keyword">int</span> var3 = <span class="number">3</span>;
    <span class="keyword">int</span> var4 = <span class="number">4</span>;
    <span class="keyword">int</span> var5 = <span class="number">5</span>;
}
</code></pre><p>反汇编结果：</p>
<pre><code>    <span class="keyword">int</span> aArray[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}<span class="comment">;</span>
011B2F98  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">1Ch</span>],<span class="number">1</span>  
011B2F9F  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">18h</span>],<span class="number">2</span>  
011B2FA6  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">14h</span>],<span class="number">3</span>  
011B2FAD  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">10h</span>],<span class="number">4</span>  
011B2FB4  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>],<span class="number">5</span>  
    <span class="keyword">int</span> var1 = <span class="number">1</span><span class="comment">;</span>
011B2FBB  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">28h</span>],<span class="number">1</span>  
    <span class="keyword">int</span> var2 = <span class="number">2</span><span class="comment">;</span>
011B2FC2  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">34h</span>],<span class="number">2</span>  
    <span class="keyword">int</span> var3 = <span class="number">3</span><span class="comment">;</span>
011B2FC9  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">40h</span>],<span class="number">3</span>  
    <span class="keyword">int</span> var4 = <span class="number">4</span><span class="comment">;</span>
011B2FD0  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4Ch</span>],<span class="number">4</span>  
    <span class="keyword">int</span> var5 = <span class="number">5</span><span class="comment">;</span>
011B2FD7  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">58h</span>],<span class="number">5</span>  
</code></pre><p>可以看出，连续定义同一种类型的变量，这点和数组相同。如果连续定义的变量数据类型不同，则跟数组的反汇编结果就完全不一样了，根据这些特征可以判断是否为数组。</p>
<h2 id="2、数组作为参数">2、数组作为参数</h2><p>数组所占的内存，通常大于4个字节，那么它是如何传递参数的呢？<br>测试代码如下：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">char</span> szBuff[])</span>
</span>{
    <span class="built_in">strcpy</span>(szBuff,<span class="string">"hello world"</span>);
    <span class="built_in">printf</span>(szBuff);
}

<span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    <span class="keyword">char</span> szHello[<span class="number">20</span>] = {<span class="number">0</span>};
    Show(szHello);
}
</code></pre><p>反汇编代码：</p>
<p><img src="/uploads/2014/07/1117015845.png" alt="1.png"></p>
<p>通过上图，可以看出，当数组作为参数时，传递的是数组的首地址（指针变量）。因为是参数是指针变量，因此，使用sizeof只能得到指针长度，因此，应该避免如下错误代码：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">char</span> szBuff[])</span>
</span>{
    <span class="keyword">int</span> nLen = <span class="number">0</span>;

    <span class="comment">//这里是错误代码，得到的是指针长度,4字节</span>
    nLen =  <span class="keyword">sizeof</span>(szBuff);
    <span class="built_in">printf</span>(<span class="string">"%d ,"</span>,nLen);

    <span class="comment">//正确的使用方法</span>
    nLen = <span class="built_in">strlen</span>(szBuff);
    <span class="built_in">printf</span>(<span class="string">"%d ,"</span>,nLen);

    getchar();
}
</code></pre><h2 id="3、数组作为返回值">3、数组作为返回值</h2><p>数组作为返回值时，与作为参数时相同，都是返回数组第一个元素的地址。注意，数组作为参数时，其定义的作用域必然在函数外，但是作为返回值时，如果数组在函数内定义，作为函数的局部变量，那么开辟的栈空间，在函数结束的时候要进行堆栈平衡，esp归位。这样，函数所在的内存空间就会极不稳定，随时可能会被破坏，影响程序的结果。<br><strong>因此，如果想使用数组作为返回值，可以使用“<code>全局数组，静态数组，或者上层调用函数中定义的局部数组</code>”</strong></p>
<h2 id="4、下标寻址和指针寻址">4、下标寻址和指针寻址</h2><p>访问数组有两种方式：<code>下标寻址</code>和<code>指针寻址</code>。 </p>
<p>测试代码：</p>
<pre><code><span class="keyword">int</span> <span class="keyword">_t</span>main(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    <span class="keyword">char</span> * pChar    = NULL;
    <span class="keyword">char</span> szBuff[]    = <span class="string">"hello"</span>;
    pChar            = szBuff;
    <span class="built_in">printf</span>(<span class="string">"%c"</span>,*pChar);
    <span class="built_in">printf</span>(<span class="string">"%c"</span>,szBuff[<span class="number">0</span>]);
}
</code></pre><p>反汇编结果：</p>
<pre><code>    char * pChar    = NULL<span class="comment">;</span>
00F83318  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>],<span class="number">0</span>                      <span class="comment">;初始化指针变量</span>
    char szBuff[]    = <span class="string">"hello"</span><span class="comment">;</span>
00F8331F  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [string <span class="string">"hello"</span> (<span class="number">0F85834h</span>)]  <span class="comment">;初始化字符数组</span>
00F83324  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">1Ch</span>],<span class="number">eax</span>  
00F83327  <span class="keyword">mov</span>         <span class="number">cx</span>,<span class="preprocessor">word</span> <span class="preprocessor">ptr</span> <span class="literal">ds</span>:[<span class="number">0F85838h</span>]  
00F8332E  <span class="keyword">mov</span>         <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">18h</span>],<span class="number">cx</span>  
    pChar            = szBuff<span class="comment">;</span>
00F83332  <span class="keyword">lea</span>         <span class="number">eax</span>,[<span class="literal">ebp</span>-<span class="number">1Ch</span>]  
00F83335  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>],<span class="number">eax</span>                    <span class="comment">;对pCha重新赋值</span>
    printf(<span class="string">"%c"</span>,*pChar)<span class="comment">;</span>
00F83338  <span class="keyword">mov</span>         <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">0Ch</span>]                    <span class="comment">;取数组首地址 </span>
00F8333B  <span class="keyword">movsx</span>       <span class="number">ecx</span>,<span class="preprocessor">byte</span> <span class="preprocessor">ptr</span> [<span class="number">eax</span>]                         <span class="comment">;对首地址取值</span>
00F8333E  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
00F83340  <span class="keyword">push</span>        <span class="number">ecx</span>  
00F83341  <span class="keyword">push</span>        offset string <span class="string">"hello world"</span> (<span class="number">0F85830h</span>)  
00F83346  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">0F882B0h</span>)]  
00F8334C  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
00F8334F  <span class="keyword">cmp</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
00F83351  <span class="keyword">call</span>        @ILT+<span class="number">440</span>(__RTC_CheckEsp) (<span class="number">0F811BDh</span>)  
    printf(<span class="string">"%c"</span>,szBuff[<span class="number">0</span>])<span class="comment">;</span>
00F83356  <span class="keyword">movsx</span>       <span class="number">eax</span>,<span class="preprocessor">byte</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">1Ch</span>]                     <span class="comment">;数组首地址取值</span>
00F8335A  <span class="keyword">mov</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
00F8335C  <span class="keyword">push</span>        <span class="number">eax</span>  
00F8335D  <span class="keyword">push</span>        offset string <span class="string">"hello world"</span> (<span class="number">0F85830h</span>)  
00F83362  <span class="keyword">call</span>        <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [__imp__printf (<span class="number">0F882B0h</span>)]  
00F83368  <span class="keyword">add</span>         <span class="literal">esp</span>,<span class="number">8</span>  
00F8336B  <span class="keyword">cmp</span>         <span class="literal">esi</span>,<span class="literal">esp</span>  
00F8336D  <span class="keyword">call</span>        @ILT+<span class="number">440</span>(__RTC_CheckEsp) (<span class="number">0F811BDh</span>)  
</code></pre><p>通过上面分析，指针需要两次间接访问，才能得到数组中的值。效率比下标方式要低。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>数组和指针都是针对地址进行操作，但是他们有很多不同之处。数组是相同类型的数据集合，是以线性的方式存储在内存中；而指针是保存4个字节的地址变量。</p>
<p>数组名是一个地址常量，保存数组第一个元素的地址（不可以更改），只能作为基址访问内存数据；<br>指针是一个变量，只要]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向基础第十六篇：堆空间的申请与释放]]></title>
    <link href="http://0x520.com/2014/05/16/reverse/16/"/>
    <id>http://0x520.com/2014/05/16/reverse/16/</id>
    <published>2014-05-15T16:00:00.000Z</published>
    <updated>2015-05-23T03:27:47.000Z</updated>
    <content type="html"><![CDATA[<p>在C/C++中，使用malloc 与 new 实现堆空间的申请，返回的数据是堆空间的首地址。 对应地，使用free和delete完成堆空间的释放。但是需要堆空间的首地址。如果首地址丢失将无法释放堆空间，会导致内存泄露。</p>
<p>确定变量空间是否属于堆空间只要找到两个关键点即可：</p>
<ul>
<li>空间申请：malloc 与 new 等</li>
<li>空间释放：free 与 delete 等</li>
</ul>
<p><strong>malloc,free 与 new,delete 对比：</strong></p>
<pre><code><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    <span class="keyword">char</span> * pCharMalloc = (<span class="keyword">char</span> *) malloc(<span class="number">10</span>);
    <span class="keyword">char</span> * pCharNew =  <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];
    <span class="keyword">if</span>(pCharNew != <span class="keyword">NULL</span>)
    {
        <span class="keyword">delete</span> [] pCharNew;
        pCharNew = <span class="keyword">NULL</span>;
    }
    <span class="keyword">if</span>(pCharMalloc != <span class="keyword">NULL</span>)
    {
        free(pCharMalloc);
        pCharMalloc = <span class="keyword">NULL</span>;
    }
}
</code></pre><p>反汇编代码及解释：</p>
<p><img src="/uploads/2014/07/1580463780.png" alt="1.png"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C/C++中，使用malloc 与 new 实现堆空间的申请，返回的数据是堆空间的首地址。 对应地，使用free和delete完成堆空间的释放。但是需要堆空间的首地址。如果首地址丢失将无法释放堆空间，会导致内存泄露。</p>
<p>确定变量空间是否属于堆空间只要找到两个关]]>
    </summary>
    
      <category term="反汇编" scheme="http://0x520.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://0x520.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="逆向基础" scheme="http://0x520.com/categories/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>